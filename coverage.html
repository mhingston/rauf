
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>rauf: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">rauf/cmd/rauf/architect_questions.go (84.9%)</option>
				
				<option value="file1">rauf/cmd/rauf/backpressure.go (76.3%)</option>
				
				<option value="file2">rauf/cmd/rauf/escalation.go (85.5%)</option>
				
				<option value="file3">rauf/cmd/rauf/fence.go (100.0%)</option>
				
				<option value="file4">rauf/cmd/rauf/guardrails.go (77.0%)</option>
				
				<option value="file5">rauf/cmd/rauf/hash.go (100.0%)</option>
				
				<option value="file6">rauf/cmd/rauf/hypothesis.go (97.4%)</option>
				
				<option value="file7">rauf/cmd/rauf/logging.go (66.7%)</option>
				
				<option value="file8">rauf/cmd/rauf/main.go (48.2%)</option>
				
				<option value="file9">rauf/cmd/rauf/plan_parse.go (79.5%)</option>
				
				<option value="file10">rauf/cmd/rauf/plan_work.go (0.0%)</option>
				
				<option value="file11">rauf/cmd/rauf/prompt_render.go (59.9%)</option>
				
				<option value="file12">rauf/cmd/rauf/run_loop.go (46.6%)</option>
				
				<option value="file13">rauf/cmd/rauf/runtime_exec.go (22.6%)</option>
				
				<option value="file14">rauf/cmd/rauf/spec_index.go (59.4%)</option>
				
				<option value="file15">rauf/cmd/rauf/spec_lint.go (85.2%)</option>
				
				<option value="file16">rauf/cmd/rauf/state.go (83.0%)</option>
				
				<option value="file17">rauf/cmd/rauf/strategy.go (80.0%)</option>
				
				<option value="file18">rauf/cmd/rauf/uid_gid_unix.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "strings"
        "time"
)

const (
        baseArchitectQuestions   = 3
        bonusQuestionsPerFailure = 1
)

// maxArchitectQuestionsForState returns the dynamic limit based on backpressure state.
// Allows extra questions when the model is dealing with prior failures.
func maxArchitectQuestionsForState(state raufState) int <span class="cov8" title="1">{
        max := baseArchitectQuestions
        if state.PriorGuardrailStatus == "fail" </span><span class="cov8" title="1">{
                max += bonusQuestionsPerFailure
        }</span>
        <span class="cov8" title="1">if state.LastVerificationStatus == "fail" </span><span class="cov8" title="1">{
                max += bonusQuestionsPerFailure
        }</span>
        <span class="cov8" title="1">return max</span>
}

// runArchitectQuestions handles interactive Q&amp;A during architect mode.
// It extracts RAUF_QUESTION: lines from output and prompts the user for answers.
func runArchitectQuestions(ctx context.Context, runner runtimeExec, promptContent *string, output string, state raufState, harness, harnessArgs string, logFile *os.File, retryCfg retryConfig, reader io.Reader, writer io.Writer) (string, bool) <span class="cov8" title="1">{
        bufReader := bufio.NewReader(reader)
        totalAsked := 0
        updatedOutput := output
        maxQuestions := maxArchitectQuestionsForState(state)
        for </span><span class="cov8" title="1">{
                // Check for context cancellation at the start of each loop iteration
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return updatedOutput, totalAsked &gt; 0</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">questions := extractTypedQuestions(updatedOutput)
                if len(questions) == 0 || totalAsked &gt;= maxQuestions </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">answers := []string{}
                for _, q := range questions </span><span class="cov8" title="1">{
                        if totalAsked &gt;= maxQuestions </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">totalAsked++
                        fmt.Fprintf(writer, "Architect question: %s\n&gt; ", formatTypedQuestionForDisplay(q))

                        // Use a goroutine to read input so we can also check for context cancellation.
                        inputChan := make(chan string, 1)
                        go func() </span><span class="cov8" title="1">{
                                text, _ := bufReader.ReadString('\n')
                                select </span>{
                                case inputChan &lt;- strings.TrimSpace(text):<span class="cov8" title="1"></span>
                                default:<span class="cov0" title="0"></span>
                                }
                        }()

                        <span class="cov8" title="1">var text string
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return updatedOutput, totalAsked &gt; 0</span>
                        case text = &lt;-inputChan:<span class="cov8" title="1"></span>
                                // Got input from user
                        case &lt;-time.After(5 * time.Minute):<span class="cov0" title="0">
                                text = "(no answer provided - timeout)"</span>
                        }

                        <span class="cov8" title="1">if text == "" </span><span class="cov0" title="0">{
                                text = "(no answer provided)"
                        }</span>
                        <span class="cov8" title="1">answers = append(answers, fmt.Sprintf("Q: %s\nA: %s", formatTypedQuestionForDisplay(q), text))</span>
                }
                <span class="cov8" title="1">if len(answers) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">*promptContent = *promptContent + "\n\n# Architect Answers\n\n" + strings.Join(answers, "\n\n")
                nextResult, err := runHarness(ctx, *promptContent, harness, harnessArgs, logFile, retryCfg, runner)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Architect follow-up failed:", err)
                        return output, false
                }</span>
                <span class="cov8" title="1">updatedOutput = nextResult.Output</span>
        }
        <span class="cov8" title="1">return updatedOutput, totalAsked &gt; 0</span>
}

func extractQuestions(output string) []string <span class="cov8" title="1">{
        questions := []string{}
        var fence fenceState
        for _, line := range strings.Split(output, "\n") </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if fence.processLine(trimmed) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(trimmed, "RAUF_QUESTION:") </span><span class="cov8" title="1">{
                        question := strings.TrimSpace(strings.TrimPrefix(trimmed, "RAUF_QUESTION:"))
                        if question != "" </span><span class="cov8" title="1">{
                                questions = append(questions, question)
                        }</span>
                }
        }
        <span class="cov8" title="1">return questions</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os/exec"
        "regexp"
        "strings"
)

// highSignalPatterns are pre-compiled patterns for extracting important error lines.
// Compiled at package init time for performance.
var highSignalPatterns = []*regexp.Regexp{
        regexp.MustCompile(`(?i)\bFAIL\b`),
        regexp.MustCompile(`(?i)\bFAILED\b`),
        regexp.MustCompile(`(?i)\bERROR\b`),
        regexp.MustCompile(`(?i)\bpanic\b`),
        regexp.MustCompile(`(?i)\bundefined\b`),
        regexp.MustCompile(`(?i)no such file`),
        regexp.MustCompile(`\w+\.\w+:\d+`), // file:line pattern (e.g., foo.go:42)
        regexp.MustCompile(`^---\s*(FAIL|PASS):`),
        regexp.MustCompile(`(?i)^=== (RUN|FAIL)`),
        regexp.MustCompile(`(?i)expected.*got`),
        regexp.MustCompile(`(?i)assertion failed`),
}

// formatGuardrailBackpressure converts a guardrail reason code into an actionable instruction.
func formatGuardrailBackpressure(reason string) string <span class="cov8" title="1">{
        if reason == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">switch </span>{
        case strings.HasPrefix(reason, "forbidden_path:"):<span class="cov8" title="1">
                path := strings.TrimPrefix(reason, "forbidden_path:")
                return "You attempted to modify forbidden directory: " + path + ". Choose an alternative file/approach."</span>
        case reason == "max_files_changed":<span class="cov8" title="1">
                return "Reduce scope: modify fewer files. Prefer smaller, focused patches."</span>
        case reason == "max_commits_exceeded":<span class="cov8" title="1">
                return "Squash work into fewer commits. Complete one task at a time."</span>
        case reason == "verify_required_for_change":<span class="cov8" title="1">
                return "You must run Verify successfully before changing files. Define or fix verification first."</span>
        case reason == "plan_update_without_verify":<span class="cov8" title="1">
                return "Plan changed but verification didn't pass. Fix verification before modifying the plan."</span>
        case reason == "missing_verify_plan_not_updated":<span class="cov8" title="1">
                return "Verification is missing. Update the plan to add a valid Verify command."</span>
        case reason == "missing_verify_non_plan_change":<span class="cov8" title="1">
                return "Verification is missing. You may only update the plan until Verify is defined."</span>
        default:<span class="cov8" title="1">
                return "Guardrail violation: " + reason</span>
        }
}

// hasBackpressureResponse checks if the model output contains the required response header.
// Returns true if the output contains "## Backpressure Response" outside of code fences.
func hasBackpressureResponse(output string) bool <span class="cov8" title="1">{
        return scanLinesOutsideFence(output, func(trimmed string) bool </span><span class="cov8" title="1">{
                return strings.HasPrefix(trimmed, "## Backpressure Response")
        }</span>)
}

// summarizeVerifyOutput extracts high-signal error lines from verification output.
func summarizeVerifyOutput(output string, maxLines int) []string <span class="cov8" title="1">{
        if output == "" || maxLines &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">lines := strings.Split(output, "\n")
        result := []string{}

        for _, line := range lines </span><span class="cov8" title="1">{
                if len(result) &gt;= maxLines </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">trimmed := strings.TrimSpace(line)
                if trimmed == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, pattern := range highSignalPatterns </span><span class="cov8" title="1">{
                        if pattern.MatchString(line) </span><span class="cov8" title="1">{
                                result = append(result, trimmed)
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return result</span>
}

// generatePlanDiff creates a truncated diff excerpt when plan hash changes.
// Returns the diff content and a source indicator ("working-tree" or "staged").
func generatePlanDiff(planPath string, gitAvailable bool, maxLines int) string <span class="cov8" title="1">{
        if !gitAvailable || planPath == "" </span><span class="cov8" title="1">{
                return "Plan file was modified (git diff unavailable)."
        }</span>

        <span class="cov0" title="0">source := "working-tree"
        output, err := exec.Command("git", "diff", "--", planPath).Output()
        if err != nil || len(output) == 0 </span><span class="cov0" title="0">{
                // Try staged diff
                output, err = exec.Command("git", "diff", "--cached", "--", planPath).Output()
                if err != nil </span><span class="cov0" title="0">{
                        return "Plan file was modified (git diff failed)."
                }</span>
                <span class="cov0" title="0">source = "staged"</span>
        }

        <span class="cov0" title="0">if len(output) == 0 </span><span class="cov0" title="0">{
                return "Plan file was modified (diff empty)."
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(output), "\n")
        if len(lines) &gt; maxLines </span><span class="cov0" title="0">{
                lines = lines[:maxLines]
                lines = append(lines, "... (truncated)")
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("[source: %s]\n%s", source, strings.Join(lines, "\n"))</span>
}

// buildBackpressurePack assembles the complete Backpressure Pack section for injection.
func buildBackpressurePack(state raufState, gitAvailable bool) string <span class="cov8" title="1">{
        var b strings.Builder

        // Check if there's any backpressure to report
        hasGuardrail := state.PriorGuardrailStatus == "fail" &amp;&amp; state.PriorGuardrailReason != ""
        hasVerifyFail := state.LastVerificationStatus == "fail" &amp;&amp; state.LastVerificationOutput != ""
        hasExitReason := state.PriorExitReason != "" &amp;&amp; state.PriorExitReason != "completion_contract_satisfied"
        hasPlanDrift := state.PlanHashBefore != "" &amp;&amp; state.PlanHashAfter != "" &amp;&amp; state.PlanHashBefore != state.PlanHashAfter
        hasRetry := state.PriorRetryCount &gt; 0
        hasRecoveryMode := state.RecoveryMode != ""

        if !hasGuardrail &amp;&amp; !hasVerifyFail &amp;&amp; !hasExitReason &amp;&amp; !hasPlanDrift &amp;&amp; !hasRetry &amp;&amp; !hasRecoveryMode </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">b.WriteString("## Backpressure Pack (from previous iteration)\n\n")
        b.WriteString("**IMPORTANT: Address these issues FIRST before any new work.**\n\n")

        // Recovery mode - strict instructions based on failure type
        if hasRecoveryMode </span><span class="cov0" title="0">{
                b.WriteString("### ⚠️ Recovery Mode Active\n\n")
                switch state.RecoveryMode </span>{
                case "verify":<span class="cov0" title="0">
                        b.WriteString("**Mode: VERIFY RECOVERY**\n")
                        b.WriteString("- Only fix the verification failure.\n")
                        b.WriteString("- Do NOT start new work or make unrelated changes.\n")
                        b.WriteString("- Focus exclusively on making the test pass.\n\n")</span>
                case "guardrail":<span class="cov0" title="0">
                        b.WriteString("**Mode: GUARDRAIL RECOVERY**\n")
                        b.WriteString("- Only adjust your approach to unblock the guardrail.\n")
                        b.WriteString("- Do NOT retry the forbidden change.\n")
                        b.WriteString("- Choose an alternative file or strategy.\n\n")</span>
                case "no_progress":<span class="cov0" title="0">
                        b.WriteString("**Mode: NO-PROGRESS RECOVERY**\n")
                        b.WriteString("- You must either:\n")
                        b.WriteString("  1. Reduce scope to a smaller, achievable change, OR\n")
                        b.WriteString("  2. Ask a clarifying question via RAUF_QUESTION, OR\n")
                        b.WriteString("  3. Explicitly abandon this approach and try a different strategy\n")
                        b.WriteString("- Doing the same thing again will NOT work.\n\n")</span>
                }
        }

        // Priority ordering
        <span class="cov8" title="1">b.WriteString("**Priority:**\n")
        b.WriteString("1. Resolve Guardrail Failures\n")
        b.WriteString("2. Fix Verification Failures\n")
        b.WriteString("3. Address Plan Changes\n")
        b.WriteString("4. Address stalling/retry issues if present (often caused by excessive output or repeated tool usage)\n\n")

        // Guardrail failure
        if hasGuardrail </span><span class="cov8" title="1">{
                b.WriteString("### Guardrail Failure\n\n")
                b.WriteString("- Status: **BLOCKED**\n")
                b.WriteString("- Reason: `")
                b.WriteString(state.PriorGuardrailReason)
                b.WriteString("`\n")
                b.WriteString("- Action Required: ")
                b.WriteString(formatGuardrailBackpressure(state.PriorGuardrailReason))
                b.WriteString("\n\n")
        }</span>

        // Verification failure
        <span class="cov8" title="1">if hasVerifyFail </span><span class="cov8" title="1">{
                b.WriteString("### Verification Failure\n\n")
                b.WriteString("- Verify Command: `")
                b.WriteString(state.LastVerificationCommand)
                b.WriteString("`\n")
                b.WriteString("- Status: **FAIL**\n")
                if state.ConsecutiveVerifyFails &gt;= 2 </span><span class="cov8" title="1">{
                        b.WriteString("- Consecutive Failures: ")
                        b.WriteString(fmt.Sprintf("%d\n", state.ConsecutiveVerifyFails))
                        b.WriteString("- **HYPOTHESIS REQUIRED**: Before attempting another fix, you MUST:\n")
                        b.WriteString("  1. State your diagnosis of why the previous fix failed\n")
                        b.WriteString("  2. Explain what you will do differently this time\n")
                        b.WriteString("  3. Only then proceed with the fix\n\n")
                }</span> else<span class="cov8" title="1"> {
                        b.WriteString("- Action Required: Fix these errors before any new work.\n\n")
                }</span>

                <span class="cov8" title="1">keyErrors := summarizeVerifyOutput(state.LastVerificationOutput, 30)
                if len(keyErrors) &gt; 0 </span><span class="cov8" title="1">{
                        b.WriteString("**Key Errors:**\n\n```\n")
                        for _, line := range keyErrors </span><span class="cov8" title="1">{
                                b.WriteString(line)
                                b.WriteString("\n")
                        }</span>
                        <span class="cov8" title="1">b.WriteString("```\n\n")</span>
                }
        }

        // Exit reason from previous iteration
        <span class="cov8" title="1">if hasExitReason </span><span class="cov8" title="1">{
                b.WriteString("### Prior Exit Reason\n\n")
                b.WriteString("- Reason: `")
                b.WriteString(state.PriorExitReason)
                b.WriteString("`\n")
                switch state.PriorExitReason </span>{
                case "no_progress":<span class="cov8" title="1">
                        b.WriteString("- Action Required: Make meaningful progress. Consider:\n")
                        b.WriteString("  - Reducing scope to a smaller change\n")
                        b.WriteString("  - Re-running verification with additional diagnostics\n")
                        b.WriteString("  - Asking a clarifying question via RAUF_QUESTION\n")
                        b.WriteString("  - Abandoning the current approach and trying a different strategy\n\n")</span>
                case "no_unchecked_tasks":<span class="cov0" title="0">
                        b.WriteString("- Note: All tasks complete. Emit RAUF_COMPLETE if done.\n\n")</span>
                default:<span class="cov0" title="0">
                        b.WriteString("\n")</span>
                }
        }

        // Plan drift
        <span class="cov8" title="1">if hasPlanDrift </span><span class="cov8" title="1">{
                b.WriteString("### Plan Changes Detected\n\n")
                b.WriteString("- Plan was modified in the previous iteration.\n")
                b.WriteString("- Action Required: Keep plan edits minimal and justify them explicitly.\n")
                if state.PlanDiffSummary != "" </span><span class="cov8" title="1">{
                        b.WriteString("\n**Diff excerpt:**\n\n```diff\n")
                        b.WriteString(state.PlanDiffSummary)
                        b.WriteString("\n```\n")
                }</span>
                <span class="cov8" title="1">b.WriteString("\n")</span>
        }

        // Harness retries
        <span class="cov8" title="1">if hasRetry </span><span class="cov8" title="1">{
                b.WriteString("### Harness Retries\n\n")
                b.WriteString(fmt.Sprintf("- Retries: %d\n", state.PriorRetryCount))
                if state.PriorRetryReason != "" </span><span class="cov8" title="1">{
                        b.WriteString("- Matched: `" + state.PriorRetryReason + "`\n")
                }</span>
                <span class="cov8" title="1">b.WriteString("- Note: The harness experienced transient failures (e.g., rate limits).\n")
                b.WriteString("- Action: Keep responses concise, avoid large file dumps, reduce tool calls per iteration.\n\n")</span>
        }

        <span class="cov8" title="1">b.WriteString("---\n\n")
        return b.String()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "strings"
)

// escalationConfig defines model escalation behavior.
type escalationConfig struct {
        Enabled                bool
        ConsecutiveVerifyFails int // Trigger: escalate after N consecutive verify failures
        NoProgressIters        int // Trigger: escalate after N no-progress iterations
        GuardrailFailures      int // Trigger: escalate after N consecutive guardrail failures
        CooldownIters          int // Wait N iterations before de-escalating
        MaxEscalations         int // Maximum number of escalations per run
}

// defaultEscalationConfig returns the default (disabled) escalation config.
func defaultEscalationConfig() escalationConfig <span class="cov8" title="1">{
        return escalationConfig{
                Enabled:                false,
                ConsecutiveVerifyFails: 2,
                NoProgressIters:        2,
                GuardrailFailures:      2,
                CooldownIters:          2,
                MaxEscalations:         2,
        }
}</span>

// shouldEscalateModel determines if we should switch to the stronger model.
// Returns true if escalation is warranted and the reason.
func shouldEscalateModel(state raufState, cfg runtimeConfig) (bool, string) <span class="cov8" title="1">{
        if !cfg.ModelEscalation.Enabled </span><span class="cov8" title="1">{
                return false, ""
        }</span>
        <span class="cov8" title="1">if cfg.ModelStrong == "" </span><span class="cov8" title="1">{
                return false, ""
        }</span>
        // Already at max escalations
        <span class="cov8" title="1">if state.EscalationCount &gt;= cfg.ModelEscalation.MaxEscalations </span><span class="cov8" title="1">{
                return false, ""
        }</span>
        // Already escalated and still in cooldown
        <span class="cov8" title="1">if state.CurrentModel == cfg.ModelStrong &amp;&amp; state.EscalationCooldownRemaining &gt; 0 </span><span class="cov0" title="0">{
                return false, ""
        }</span>

        // Check triggers
        <span class="cov8" title="1">if cfg.ModelEscalation.ConsecutiveVerifyFails &gt; 0 &amp;&amp;
                state.ConsecutiveVerifyFails &gt;= cfg.ModelEscalation.ConsecutiveVerifyFails </span><span class="cov8" title="1">{
                return true, "consecutive_verify_fails"
        }</span>
        <span class="cov8" title="1">if cfg.ModelEscalation.NoProgressIters &gt; 0 &amp;&amp;
                state.NoProgressStreak &gt;= cfg.ModelEscalation.NoProgressIters </span><span class="cov8" title="1">{
                return true, "no_progress_iters"
        }</span>
        <span class="cov8" title="1">if cfg.ModelEscalation.GuardrailFailures &gt; 0 &amp;&amp;
                state.ConsecutiveGuardrailFails &gt;= cfg.ModelEscalation.GuardrailFailures </span><span class="cov8" title="1">{
                return true, "guardrail_failures"
        }</span>

        <span class="cov8" title="1">return false, ""</span>
}

// shouldDeescalateModel determines if we should return to the default model.
func shouldDeescalateModel(state raufState, cfg runtimeConfig) bool <span class="cov8" title="1">{
        if !cfg.ModelEscalation.Enabled </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if state.CurrentModel != cfg.ModelStrong </span><span class="cov8" title="1">{
                return false
        }</span>
        // De-escalate if cooldown has expired
        <span class="cov8" title="1">return state.EscalationCooldownRemaining &lt;= 0</span>
}

// computeEffectiveModel returns the model to use for this iteration.
func computeEffectiveModel(state raufState, cfg runtimeConfig) string <span class="cov8" title="1">{
        if !cfg.ModelEscalation.Enabled </span><span class="cov8" title="1">{
                return cfg.ModelDefault
        }</span>
        <span class="cov8" title="1">if state.CurrentModel != "" </span><span class="cov8" title="1">{
                return state.CurrentModel
        }</span>
        <span class="cov0" title="0">return cfg.ModelDefault</span>
}

// applyModelChoice injects the model flag into harness args if not already present.
// If the model flag already exists in args, respects the existing value by default.
func applyModelChoice(harnessArgs, modelFlag, modelName string) string <span class="cov8" title="1">{
        if modelFlag == "" || modelName == "" </span><span class="cov8" title="1">{
                return harnessArgs
        }</span>

        // Check if model flag already exists in args
        <span class="cov8" title="1">if containsModelFlag(harnessArgs, modelFlag) </span><span class="cov8" title="1">{
                // Respect existing flag - don't override
                return harnessArgs
        }</span>

        // Append model flag
        <span class="cov8" title="1">if harnessArgs == "" </span><span class="cov8" title="1">{
                return modelFlag + " " + modelName
        }</span>
        <span class="cov8" title="1">return harnessArgs + " " + modelFlag + " " + modelName</span>
}

// containsModelFlag checks if the harness args already contain the model flag.
func containsModelFlag(harnessArgs, modelFlag string) bool <span class="cov8" title="1">{
        if modelFlag == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        // Check for flag as a word boundary
        <span class="cov8" title="1">parts := strings.Fields(harnessArgs)
        for _, part := range parts </span><span class="cov8" title="1">{
                if part == modelFlag || strings.HasPrefix(part, modelFlag+"=") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// updateEscalationState updates the state after an iteration based on backpressure signals.
// Returns the updated state.
func updateEscalationState(state raufState, cfg runtimeConfig,
        verifyFailed bool, guardrailFailed bool, noProgress bool) raufState <span class="cov8" title="1">{

        if !cfg.ModelEscalation.Enabled </span><span class="cov8" title="1">{
                return state
        }</span>

        // Track consecutive verify failures
        <span class="cov8" title="1">if verifyFailed </span><span class="cov8" title="1">{
                state.ConsecutiveVerifyFails++
        }</span> else<span class="cov8" title="1"> {
                state.ConsecutiveVerifyFails = 0
        }</span>

        // Track consecutive guardrail failures
        <span class="cov8" title="1">if guardrailFailed </span><span class="cov0" title="0">{
                state.ConsecutiveGuardrailFails++
        }</span> else<span class="cov8" title="1"> {
                state.ConsecutiveGuardrailFails = 0
        }</span>

        // Track no-progress streak
        <span class="cov8" title="1">if noProgress </span><span class="cov0" title="0">{
                state.NoProgressStreak++
        }</span> else<span class="cov8" title="1"> {
                state.NoProgressStreak = 0
        }</span>

        // Manage cooldown
        <span class="cov8" title="1">if state.EscalationCooldownRemaining &gt; 0 </span><span class="cov0" title="0">{
                state.EscalationCooldownRemaining--
        }</span>

        // Check for escalation
        <span class="cov8" title="1">if shouldEscalate, reason := shouldEscalateModel(state, cfg); shouldEscalate </span><span class="cov8" title="1">{
                if state.CurrentModel != cfg.ModelStrong </span><span class="cov8" title="1">{
                        state.CurrentModel = cfg.ModelStrong
                        state.EscalationCount++
                        state.EscalationCooldownRemaining = cfg.ModelEscalation.CooldownIters
                        state.LastEscalationReason = reason
                }</span>
        } else<span class="cov8" title="1"> if shouldDeescalateModel(state, cfg) </span><span class="cov0" title="0">{
                // De-escalate to default model
                state.CurrentModel = cfg.ModelDefault
                state.LastEscalationReason = ""
        }</span>

        // Recovery mode logic (optional, based on consecutive failures)
        <span class="cov8" title="1">if state.ConsecutiveVerifyFails &gt;= 2 || state.NoProgressStreak &gt;= 2 </span><span class="cov8" title="1">{
                state.RecoveryMode = "verify"
        }</span> else<span class="cov8" title="1"> if state.ConsecutiveGuardrailFails &gt;= 2 </span><span class="cov0" title="0">{
                state.RecoveryMode = "guardrail"
        }</span> else<span class="cov8" title="1"> if !verifyFailed &amp;&amp; !guardrailFailed &amp;&amp; !noProgress </span><span class="cov8" title="1">{
                state.RecoveryMode = ""
        }</span>

        <span class="cov8" title="1">return state</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import "strings"

// fenceState tracks code fence parsing state.
type fenceState struct {
        inFence   bool
        fenceChar byte
        fenceLen  int
}

// processLine updates fence state based on the current line.
// Returns true if the line is inside a code fence (should be skipped for content matching).
func (f *fenceState) processLine(trimmed string) bool <span class="cov8" title="1">{
        if len(trimmed) &lt; 3 </span><span class="cov8" title="1">{
                return f.inFence
        }</span>

        <span class="cov8" title="1">if !f.inFence </span><span class="cov8" title="1">{
                // Check for opening fence
                if trimmed[0] == '`' || trimmed[0] == '~' </span><span class="cov8" title="1">{
                        fenceChar := trimmed[0]
                        fenceLen := countLeadingChars(trimmed, fenceChar)
                        if fenceLen &gt;= 3 </span><span class="cov8" title="1">{
                                // Valid opening fence: at least 3 chars, rest is optional language identifier
                                f.inFence = true
                                f.fenceChar = fenceChar
                                f.fenceLen = fenceLen
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }

        // Check for closing fence
        <span class="cov8" title="1">if trimmed[0] == f.fenceChar </span><span class="cov8" title="1">{
                count := countLeadingChars(trimmed, f.fenceChar)
                // Closing fence must have at least as many chars as opening
                // and must consist ONLY of fence characters (no trailing content)
                if count &gt;= f.fenceLen &amp;&amp; count == len(trimmed) </span><span class="cov8" title="1">{
                        f.inFence = false
                        f.fenceChar = 0
                        f.fenceLen = 0
                        return true
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// countLeadingChars counts consecutive occurrences of char at the start of s.
func countLeadingChars(s string, char byte) int <span class="cov8" title="1">{
        count := 0
        for count &lt; len(s) &amp;&amp; s[count] == char </span><span class="cov8" title="1">{
                count++
        }</span>
        <span class="cov8" title="1">return count</span>
}

// scanLinesOutsideFence iterates over lines and calls the match function
// for each line that is outside of code fences.
// Returns true if match returns true for any line.
func scanLinesOutsideFence(output string, match func(trimmed string) bool) bool <span class="cov8" title="1">{
        var fence fenceState
        for _, line := range strings.Split(output, "\n") </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if fence.processLine(trimmed) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if match(trimmed) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "os"
        "path/filepath"
        "strconv"
        "strings"
)

func enforceGuardrails(cfg runtimeConfig, headBefore, headAfter string) (bool, string) <span class="cov8" title="1">{
        if cfg.MaxCommits &gt; 0 </span><span class="cov0" title="0">{
                count, err := gitOutput("rev-list", "--count", headBefore+".."+headAfter)
                if err != nil </span><span class="cov0" title="0">{
                        // Fail-closed: if we can't check commit count, reject to be safe
                        return false, "git_error_commit_count"
                }</span>
                <span class="cov0" title="0">if v := strings.TrimSpace(count); v != "" </span><span class="cov0" title="0">{
                        if n, err := strconv.Atoi(v); err == nil &amp;&amp; n &gt; cfg.MaxCommits </span><span class="cov0" title="0">{
                                return false, "max_commits_exceeded"
                        }</span>
                }
        }

        <span class="cov8" title="1">files := []string{}
        gitFilesErr := false
        if headAfter != headBefore </span><span class="cov0" title="0">{
                names, err := gitOutput("diff", "--name-only", headBefore+".."+headAfter)
                if err != nil </span><span class="cov0" title="0">{
                        gitFilesErr = true
                }</span> else<span class="cov0" title="0"> {
                        files = append(files, splitLines(names)...)
                }</span>
        } else<span class="cov8" title="1"> {
                status, err := gitOutputRaw("status", "--porcelain")
                if err != nil </span><span class="cov0" title="0">{
                        gitFilesErr = true
                }</span> else<span class="cov8" title="1"> {
                        for _, line := range splitStatusLines(status) </span><span class="cov8" title="1">{
                                // Git porcelain v1 format: "XY PATH" where XY are 2 status chars followed by space
                                // Minimum valid: 2 status + 1 space + 1 char path = 4 chars
                                if len(line) &lt; 4 </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">path := parseStatusPath(line[3:])
                                if path == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">files = append(files, path)</span>
                        }
                }
        }

        // Fail-closed: if we can't get the file list and there are guardrails that depend on it
        <span class="cov8" title="1">if gitFilesErr &amp;&amp; (cfg.MaxFilesChanged &gt; 0 || len(cfg.ForbiddenPaths) &gt; 0) </span><span class="cov0" title="0">{
                return false, "git_error_file_list"
        }</span>

        <span class="cov8" title="1">if cfg.MaxFilesChanged &gt; 0 &amp;&amp; len(files) &gt; cfg.MaxFilesChanged </span><span class="cov0" title="0">{
                return false, "max_files_changed"
        }</span>

        <span class="cov8" title="1">if len(cfg.ForbiddenPaths) &gt; 0 </span><span class="cov8" title="1">{
                root, rootErr := os.Getwd()
                for _, file := range files </span><span class="cov8" title="1">{
                        fileClean := filepath.Clean(file)
                        fileAbs := fileClean
                        if rootErr == nil &amp;&amp; !filepath.IsAbs(fileClean) </span><span class="cov8" title="1">{
                                fileAbs = filepath.Join(root, fileClean)
                        }</span>
                        <span class="cov8" title="1">for _, forbidden := range cfg.ForbiddenPaths </span><span class="cov8" title="1">{
                                forbidden = filepath.Clean(strings.TrimSpace(forbidden))
                                if forbidden == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if rootErr == nil </span><span class="cov8" title="1">{
                                        forbiddenAbs := forbidden
                                        if !filepath.IsAbs(forbidden) </span><span class="cov8" title="1">{
                                                forbiddenAbs = filepath.Join(root, forbidden)
                                        }</span>
                                        <span class="cov8" title="1">if fileAbs == forbiddenAbs || strings.HasPrefix(fileAbs, forbiddenAbs+string(filepath.Separator)) </span><span class="cov8" title="1">{
                                                return false, "forbidden_path:" + forbidden
                                        }</span>
                                } else<span class="cov0" title="0"> if fileClean == forbidden || strings.HasPrefix(fileClean, forbidden+string(filepath.Separator)) </span><span class="cov0" title="0">{
                                        return false, "forbidden_path:" + forbidden
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return true, ""</span>
}

func enforceVerificationGuardrails(cfg runtimeConfig, verifyStatus string, planChanged bool, worktreeChanged bool) (bool, string) <span class="cov8" title="1">{
        if cfg.RequireVerifyForPlanUpdate &amp;&amp; planChanged &amp;&amp; verifyStatus != "pass" </span><span class="cov8" title="1">{
                return false, "plan_update_without_verify"
        }</span>
        <span class="cov8" title="1">if cfg.RequireVerifyOnChange &amp;&amp; worktreeChanged &amp;&amp; verifyStatus == "skipped" </span><span class="cov8" title="1">{
                return false, "verify_required_for_change"
        }</span>
        <span class="cov8" title="1">return true, ""</span>
}

func enforceMissingVerifyGuardrail(planPath, headBefore, headAfter string, planChanged bool) (bool, string) <span class="cov8" title="1">{
        if !planChanged </span><span class="cov0" title="0">{
                return false, "missing_verify_plan_not_updated"
        }</span>
        <span class="cov8" title="1">root, rootErr := os.Getwd()
        planPath = filepath.Clean(planPath)
        if rootErr == nil &amp;&amp; !filepath.IsAbs(planPath) </span><span class="cov8" title="1">{
                planPath = filepath.Join(root, planPath)
        }</span>
        <span class="cov8" title="1">files, gitErr := listChangedFiles(headBefore, headAfter)
        if gitErr </span><span class="cov0" title="0">{
                // Fail-closed: if we can't determine changed files, reject to be safe
                return false, "git_error_file_list"
        }</span>
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                path := filepath.Clean(file)
                if rootErr == nil &amp;&amp; !filepath.IsAbs(path) </span><span class="cov8" title="1">{
                        path = filepath.Join(root, path)
                }</span>
                <span class="cov8" title="1">if path != planPath </span><span class="cov8" title="1">{
                        return false, "missing_verify_non_plan_change"
                }</span>
        }
        <span class="cov8" title="1">return true, ""</span>
}

func enforceMissingVerifyNoGit(planChanged bool, fingerprintBefore, fingerprintAfter string) (bool, string) <span class="cov8" title="1">{
        if !planChanged </span><span class="cov8" title="1">{
                return false, "missing_verify_plan_not_updated"
        }</span>
        <span class="cov8" title="1">if fingerprintBefore != "" &amp;&amp; fingerprintAfter != "" &amp;&amp; fingerprintBefore != fingerprintAfter </span><span class="cov8" title="1">{
                return false, "missing_verify_non_plan_change"
        }</span>
        <span class="cov8" title="1">return true, ""</span>
}

// listChangedFiles returns a list of changed files and whether there was a git error.
// When gitErr is true, callers should fail-closed to avoid bypassing guardrails.
func listChangedFiles(headBefore, headAfter string) (files []string, gitErr bool) <span class="cov8" title="1">{
        files = []string{}
        if headAfter != headBefore </span><span class="cov0" title="0">{
                names, err := gitOutput("diff", "--name-only", headBefore+".."+headAfter)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, true
                }</span>
                <span class="cov0" title="0">files = append(files, splitLines(names)...)</span>
        } else<span class="cov8" title="1"> {
                status, err := gitOutputRaw("status", "--porcelain")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, true
                }</span>
                <span class="cov8" title="1">for _, line := range splitStatusLines(status) </span><span class="cov8" title="1">{
                        // Git porcelain v1 format: "XY PATH" where XY are 2 status chars followed by space
                        // Minimum valid: 2 status + 1 space + 1 char path = 4 chars
                        if len(line) &lt; 4 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">path := parseStatusPath(line[3:])
                        if path == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">files = append(files, path)</span>
                }
        }
        <span class="cov8" title="1">return files, false</span>
}

func parseStatusPath(value string) string <span class="cov8" title="1">{
        value = strings.TrimSpace(value)
        if value == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        // Check for rename indicator. Git format: "old path" -&gt; "new path" or old -&gt; new
        // Only split on " -&gt; " if it's outside quotes to avoid false positives
        // for filenames containing " -&gt; "
        <span class="cov8" title="1">arrowIdx := findUnquotedArrow(value)
        if arrowIdx &gt;= 0 </span><span class="cov8" title="1">{
                return unquoteGitPath(strings.TrimSpace(value[arrowIdx+4:]))
        }</span>
        // Git uses C-style quoting for paths with special characters
        <span class="cov8" title="1">return unquoteGitPath(value)</span>
}

// findUnquotedArrow finds " -&gt; " outside of quoted strings.
// Returns the index of the space before "-&gt;", or -1 if not found.
func findUnquotedArrow(s string) int <span class="cov8" title="1">{
        inQuote := false
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                if s[i] == '"' </span><span class="cov8" title="1">{
                        // Toggle quote state, handling escaped quotes.
                        // A quote is escaped if preceded by an odd number of backslashes.
                        if !inQuote </span><span class="cov8" title="1">{
                                inQuote = true
                        }</span> else<span class="cov8" title="1"> {
                                // Count preceding backslashes
                                numBackslashes := 0
                                for j := i - 1; j &gt;= 0 &amp;&amp; s[j] == '\\'; j-- </span><span class="cov0" title="0">{
                                        numBackslashes++
                                }</span>
                                // Odd number of backslashes means the quote is escaped
                                <span class="cov8" title="1">if numBackslashes%2 == 1 </span>{<span class="cov0" title="0">
                                        // Escaped quote, stay in quote
                                }</span> else<span class="cov8" title="1"> {
                                        inQuote = false
                                }</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if !inQuote &amp;&amp; i+4 &lt;= len(s) &amp;&amp; s[i:i+4] == " -&gt; " </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// unquoteGitPath handles git's C-style quoting for paths with special characters.
// Git quotes paths that contain special characters (spaces, non-ASCII, etc.)
// using C-style escaping with surrounding double quotes.
func unquoteGitPath(path string) string <span class="cov8" title="1">{
        path = strings.TrimSpace(path)
        if len(path) &lt; 2 || path[0] != '"' || path[len(path)-1] != '"' </span><span class="cov8" title="1">{
                return path
        }</span>
        // Remove surrounding quotes
        <span class="cov8" title="1">inner := path[1 : len(path)-1]
        // Handle common C-style escape sequences
        var result strings.Builder
        result.Grow(len(inner))
        i := 0
        for i &lt; len(inner) </span><span class="cov8" title="1">{
                if inner[i] == '\\' &amp;&amp; i+1 &lt; len(inner) </span><span class="cov8" title="1">{
                        switch inner[i+1] </span>{
                        case '\\':<span class="cov8" title="1">
                                result.WriteByte('\\')
                                i += 2</span>
                        case '"':<span class="cov8" title="1">
                                result.WriteByte('"')
                                i += 2</span>
                        case 'n':<span class="cov8" title="1">
                                result.WriteByte('\n')
                                i += 2</span>
                        case 't':<span class="cov8" title="1">
                                result.WriteByte('\t')
                                i += 2</span>
                        case 'r':<span class="cov0" title="0">
                                result.WriteByte('\r')
                                i += 2</span>
                        default:<span class="cov8" title="1">
                                // For octal sequences like \302\240, decode them
                                if i+3 &lt; len(inner) &amp;&amp; isOctalDigit(inner[i+1]) &amp;&amp; isOctalDigit(inner[i+2]) &amp;&amp; isOctalDigit(inner[i+3]) </span><span class="cov8" title="1">{
                                        val := int(inner[i+1]-'0')*64 + int(inner[i+2]-'0')*8 + int(inner[i+3]-'0')
                                        // Validate octal value is within byte range (0-255)
                                        if val &gt; 255 </span><span class="cov0" title="0">{
                                                // Invalid octal sequence, preserve as-is
                                                result.WriteByte(inner[i])
                                                i++
                                        }</span> else<span class="cov8" title="1"> {
                                                result.WriteByte(byte(val))
                                                i += 4
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        result.WriteByte(inner[i])
                                        i++
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        result.WriteByte(inner[i])
                        i++
                }</span>
        }
        <span class="cov8" title="1">return result.String()</span>
}

func isOctalDigit(b byte) bool <span class="cov8" title="1">{
        return b &gt;= '0' &amp;&amp; b &lt;= '7'
}</span>

func splitLines(value string) []string <span class="cov8" title="1">{
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">lines := strings.Split(value, "\n")
        out := []string{}
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimSpace(line)
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, line)</span>
        }
        <span class="cov8" title="1">return out</span>
}

func splitStatusLines(value string) []string <span class="cov8" title="1">{
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">lines := strings.Split(value, "\n")
        out := []string{}
        for _, line := range lines </span><span class="cov8" title="1">{
                line = strings.TrimRight(line, "\r")
                if strings.TrimSpace(line) == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">out = append(out, line)</span>
        }
        <span class="cov8" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "crypto/sha256"
        "fmt"
)

func fileHashFromString(value string) string <span class="cov8" title="1">{
        sum := sha256.Sum256([]byte(value))
        return fmt.Sprintf("%x", sum)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "strings"
        "time"
)

// Hypothesis represents a structured hypothesis entry from model output.
type Hypothesis struct {
        Timestamp       time.Time `json:"timestamp"`
        Iteration       int       `json:"iteration"`
        Hypothesis      string    `json:"hypothesis"`
        DifferentAction string    `json:"different_action"`
        VerifyCommand   string    `json:"verify_command,omitempty"`
}

// TypedQuestion represents a question with an optional type tag.
type TypedQuestion struct {
        Type     string // CLARIFY, DECISION, ASSUMPTION, or empty
        Question string
}

// extractHypothesis parses model output for HYPOTHESIS: and DIFFERENT_THIS_TIME: or DIFFERENT: lines.
// Returns the hypothesis if found, with empty strings if not present.
func extractHypothesis(output string) (hypothesis, differentAction string) <span class="cov8" title="1">{
        var fence fenceState
        for _, line := range strings.Split(output, "\n") </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if fence.processLine(trimmed) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(trimmed, "HYPOTHESIS:") </span><span class="cov8" title="1">{
                        hypothesis = strings.TrimSpace(strings.TrimPrefix(trimmed, "HYPOTHESIS:"))
                }</span>
                <span class="cov8" title="1">if strings.HasPrefix(trimmed, "DIFFERENT_THIS_TIME:") </span><span class="cov8" title="1">{
                        differentAction = strings.TrimSpace(strings.TrimPrefix(trimmed, "DIFFERENT_THIS_TIME:"))
                }</span>
                // Also accept the shorter alias
                <span class="cov8" title="1">if strings.HasPrefix(trimmed, "DIFFERENT:") &amp;&amp; differentAction == "" </span><span class="cov8" title="1">{
                        differentAction = strings.TrimSpace(strings.TrimPrefix(trimmed, "DIFFERENT:"))
                }</span>
        }
        <span class="cov8" title="1">return hypothesis, differentAction</span>
}

// hasRequiredHypothesis checks if the model output contains a valid hypothesis
// when one is required (e.g., after consecutive verify failures).
func hasRequiredHypothesis(output string) bool <span class="cov8" title="1">{
        hypothesis, differentAction := extractHypothesis(output)
        return hypothesis != "" &amp;&amp; differentAction != ""
}</span>

// extractTypedQuestions parses model output for RAUF_QUESTION lines with optional type tags.
// Supports formats:
//   - RAUF_QUESTION:CLARIFY: question text
//   - RAUF_QUESTION:DECISION: question text
//   - RAUF_QUESTION:ASSUMPTION: question text
//   - RAUF_QUESTION: question text (no type)
func extractTypedQuestions(output string) []TypedQuestion <span class="cov8" title="1">{
        questions := []TypedQuestion{}
        var fence fenceState
        for _, line := range strings.Split(output, "\n") </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if fence.processLine(trimmed) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(trimmed, "RAUF_QUESTION:") </span><span class="cov8" title="1">{
                        rest := strings.TrimPrefix(trimmed, "RAUF_QUESTION:")
                        rest = strings.TrimSpace(rest)
                        if rest == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">q := TypedQuestion{}

                        // Check for type prefix
                        for _, tag := range []string{"CLARIFY:", "DECISION:", "ASSUMPTION:"} </span><span class="cov8" title="1">{
                                if strings.HasPrefix(rest, tag) </span><span class="cov8" title="1">{
                                        q.Type = strings.TrimSuffix(tag, ":")
                                        q.Question = strings.TrimSpace(strings.TrimPrefix(rest, tag))
                                        break</span>
                                }
                        }

                        // No type tag found
                        <span class="cov8" title="1">if q.Type == "" </span><span class="cov8" title="1">{
                                q.Question = rest
                        }</span>

                        <span class="cov8" title="1">if q.Question != "" </span><span class="cov8" title="1">{
                                questions = append(questions, q)
                        }</span>
                }
        }
        <span class="cov8" title="1">return questions</span>
}

// formatTypedQuestionForDisplay formats a typed question for console display.
func formatTypedQuestionForDisplay(q TypedQuestion) string <span class="cov8" title="1">{
        if q.Type != "" </span><span class="cov8" title="1">{
                return "[" + q.Type + "] " + q.Question
        }</span>
        <span class="cov8" title="1">return q.Question</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "encoding/json"
        "os"
)

type logEntry struct {
        Type                string   `json:"type"`
        Mode                string   `json:"mode,omitempty"`
        Iteration           int      `json:"iteration,omitempty"`
        VerifyCmd           string   `json:"verify_cmd,omitempty"`
        VerifyStatus        string   `json:"verify_status,omitempty"`
        VerifyOutput        string   `json:"verify_output,omitempty"`
        PlanHash            string   `json:"plan_hash,omitempty"`
        PromptHash          string   `json:"prompt_hash,omitempty"`
        Branch              string   `json:"branch,omitempty"`
        HeadBefore          string   `json:"head_before,omitempty"`
        HeadAfter           string   `json:"head_after,omitempty"`
        Guardrail           string   `json:"guardrail,omitempty"`
        ExitReason          string   `json:"exit_reason,omitempty"`
        CompletionSignal    string   `json:"completion_signal,omitempty"`
        CompletionSpecs     []string `json:"completion_specs,omitempty"`
        CompletionArtifacts []string `json:"completion_artifacts,omitempty"`
        // Model escalation
        Model            string `json:"model,omitempty"`
        Escalated        bool   `json:"escalated,omitempty"`
        EscalationReason string `json:"escalation_reason,omitempty"`
}

func writeLogEntry(file *os.File, entry logEntry) <span class="cov8" title="1">{
        if file == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">_, _ = file.Write(append(data, '\n'))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "bufio"
        "bytes"
        "context"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "io"
        "math/rand"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "sync"
        "time"
)

const (
        defaultArchitectIterations = 10
        defaultPlanIterations      = 1
)

var version = "dev"

var defaultRetryMatch = []string{"rate limit", "429", "overloaded", "timeout"}

// jitterRng is used by jitterDuration to add randomness to retry delays.
// Initialized once at startup to avoid repeated seeding on each call.
// Protected by jitterMu for thread safety.
var (
        jitterRng = rand.New(rand.NewSource(time.Now().UnixNano()))
        jitterMu  sync.Mutex
)

type modeConfig struct {
        mode          string
        promptFile    string
        maxIterations int
        forceInit     bool
        dryRunInit    bool
        importStage   string
        importSlug    string
        importDir     string
        importForce   bool
        planPath      string
        planWorkName  string
        explicitMode  bool
}

type runtimeConfig struct {
        Harness                    string
        HarnessArgs                string
        NoPush                     bool
        LogDir                     string
        Runtime                    string
        DockerImage                string
        DockerArgs                 string
        DockerContainer            string
        Strategy                   []strategyStep
        MaxFilesChanged            int
        ForbiddenPaths             []string
        MaxCommits                 int
        NoProgressIters            int
        OnVerifyFail               string
        VerifyMissingPolicy        string
        AllowVerifyFallback        bool
        RequireVerifyOnChange      bool
        RequireVerifyForPlanUpdate bool
        RetryOnFailure             bool
        RetryMaxAttempts           int
        RetryBackoffBase           time.Duration
        RetryBackoffMax            time.Duration
        RetryJitter                bool
        RetryMatch                 []string
        RetryJitterSet             bool
        PlanLintPolicy             string
        // Model escalation
        ModelDefault    string
        ModelStrong     string
        ModelFlag       string
        ModelEscalation escalationConfig
}

type retryConfig struct {
        Enabled     bool
        MaxAttempts int
        BackoffBase time.Duration
        BackoffMax  time.Duration
        Jitter      bool
        Match       []string
}

type harnessResult struct {
        Output      string
        RetryCount  int
        RetryReason string
}

func main() <span class="cov0" title="0">{
        cfg, err := parseArgs(os.Args[1:])
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if cfg.mode == "init" </span><span class="cov0" title="0">{
                if err := runInit(cfg.forceInit, cfg.dryRunInit); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if cfg.mode == "plan-work" </span><span class="cov0" title="0">{
                if err := runPlanWork(cfg.planWorkName); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if cfg.mode == "import" </span><span class="cov0" title="0">{
                if err := runImportSpecfirst(cfg); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">if cfg.mode == "version" </span><span class="cov0" title="0">{
                fmt.Printf("rauf %s\n", version)
                return
        }</span>
        <span class="cov0" title="0">if cfg.mode == "help" </span><span class="cov0" title="0">{
                printUsage()
                return
        }</span>

        <span class="cov0" title="0">fileCfg, _, err := loadConfig("rauf.yaml")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">branch, err := gitOutput("branch", "--show-current")
        gitAvailable := err == nil &amp;&amp; branch != ""
        planPath := resolvePlanPath(branch, gitAvailable, "IMPLEMENTATION_PLAN.md")
        cfg.planPath = planPath

        noPush := fileCfg.NoPush
        if value, ok := envBool("RAUF_NO_PUSH"); ok </span><span class="cov0" title="0">{
                noPush = value
        }</span>

        <span class="cov0" title="0">harness := fileCfg.Harness
        if harness == "" </span><span class="cov0" title="0">{
                harness = "claude"
        }</span>
        <span class="cov0" title="0">if override := envFirst("RAUF_HARNESS"); override != "" </span><span class="cov0" title="0">{
                harness = override
        }</span>

        <span class="cov0" title="0">harnessArgs := fileCfg.HarnessArgs
        if override := envFirst("RAUF_HARNESS_ARGS"); override != "" </span><span class="cov0" title="0">{
                harnessArgs = override
        }</span>

        <span class="cov0" title="0">logDir := fileCfg.LogDir
        if override := envFirst("RAUF_LOG_DIR"); override != "" </span><span class="cov0" title="0">{
                logDir = override
        }</span>

        <span class="cov0" title="0">runtime := fileCfg.Runtime
        if override := envFirst("RAUF_RUNTIME"); override != "" </span><span class="cov0" title="0">{
                runtime = override
        }</span>
        <span class="cov0" title="0">dockerImage := fileCfg.DockerImage
        if override := envFirst("RAUF_DOCKER_IMAGE"); override != "" </span><span class="cov0" title="0">{
                dockerImage = override
        }</span>
        <span class="cov0" title="0">dockerArgs := fileCfg.DockerArgs
        if override := envFirst("RAUF_DOCKER_ARGS"); override != "" </span><span class="cov0" title="0">{
                dockerArgs = override
        }</span>
        <span class="cov0" title="0">dockerContainer := fileCfg.DockerContainer
        if override := envFirst("RAUF_DOCKER_CONTAINER"); override != "" </span><span class="cov0" title="0">{
                dockerContainer = override
        }</span>

        <span class="cov0" title="0">onVerifyFail := fileCfg.OnVerifyFail
        if override := envFirst("RAUF_ON_VERIFY_FAIL"); override != "" </span><span class="cov0" title="0">{
                onVerifyFail = override
        }</span>
        <span class="cov0" title="0">verifyMissingPolicy := fileCfg.VerifyMissingPolicy
        if override := envFirst("RAUF_VERIFY_MISSING_POLICY"); override != "" </span><span class="cov0" title="0">{
                verifyMissingPolicy = override
        }</span>
        <span class="cov0" title="0">allowVerifyFallback := fileCfg.AllowVerifyFallback
        if value, ok := envBool("RAUF_ALLOW_VERIFY_FALLBACK"); ok </span><span class="cov0" title="0">{
                allowVerifyFallback = value
        }</span>
        <span class="cov0" title="0">requireVerifyOnChange := fileCfg.RequireVerifyOnChange
        if value, ok := envBool("RAUF_REQUIRE_VERIFY_ON_CHANGE"); ok </span><span class="cov0" title="0">{
                requireVerifyOnChange = value
        }</span>
        <span class="cov0" title="0">requireVerifyForPlanUpdate := fileCfg.RequireVerifyForPlanUpdate
        if value, ok := envBool("RAUF_REQUIRE_VERIFY_FOR_PLAN_UPDATE"); ok </span><span class="cov0" title="0">{
                requireVerifyForPlanUpdate = value
        }</span>

        <span class="cov0" title="0">retryEnabled := fileCfg.RetryOnFailure
        if value, ok := envBool("RAUF_RETRY"); ok </span><span class="cov0" title="0">{
                retryEnabled = value
        }</span>

        <span class="cov0" title="0">retryMaxAttempts := fileCfg.RetryMaxAttempts
        if override := envFirst("RAUF_RETRY_MAX"); override != "" </span><span class="cov0" title="0">{
                if v, err := strconv.Atoi(override); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                        retryMaxAttempts = v
                }</span>
        }

        <span class="cov0" title="0">retryBackoffBase := fileCfg.RetryBackoffBase
        if override := envFirst("RAUF_RETRY_BACKOFF_BASE"); override != "" </span><span class="cov0" title="0">{
                if v, err := time.ParseDuration(override); err == nil </span><span class="cov0" title="0">{
                        retryBackoffBase = v
                }</span>
        }

        <span class="cov0" title="0">retryBackoffMax := fileCfg.RetryBackoffMax
        if override := envFirst("RAUF_RETRY_BACKOFF_MAX"); override != "" </span><span class="cov0" title="0">{
                if v, err := time.ParseDuration(override); err == nil </span><span class="cov0" title="0">{
                        retryBackoffMax = v
                }</span>
        }

        <span class="cov0" title="0">retryJitter := fileCfg.RetryJitter
        retryJitterSet := fileCfg.RetryJitterSet
        if value, ok := envBool("RAUF_RETRY_NO_JITTER"); ok </span><span class="cov0" title="0">{
                retryJitter = !value
                retryJitterSet = true
        }</span>

        <span class="cov0" title="0">retryMatch := append([]string(nil), fileCfg.RetryMatch...)
        if override := envFirst("RAUF_RETRY_MATCH"); override != "" </span><span class="cov0" title="0">{
                retryMatch = splitCommaList(override)
        }</span>

        <span class="cov0" title="0">fileCfg.DockerContainer = dockerContainer
        fileCfg.OnVerifyFail = onVerifyFail
        fileCfg.VerifyMissingPolicy = verifyMissingPolicy
        fileCfg.AllowVerifyFallback = allowVerifyFallback
        fileCfg.RequireVerifyOnChange = requireVerifyOnChange
        fileCfg.RequireVerifyForPlanUpdate = requireVerifyForPlanUpdate

        // Model escalation env overrides
        if override := envFirst("RAUF_MODEL_DEFAULT"); override != "" </span><span class="cov0" title="0">{
                fileCfg.ModelDefault = override
        }</span>
        <span class="cov0" title="0">if override := envFirst("RAUF_MODEL_STRONG"); override != "" </span><span class="cov0" title="0">{
                fileCfg.ModelStrong = override
        }</span>
        <span class="cov0" title="0">if override := envFirst("RAUF_MODEL_FLAG"); override != "" </span><span class="cov0" title="0">{
                fileCfg.ModelFlag = override
        }</span>
        <span class="cov0" title="0">if value, ok := envBool("RAUF_MODEL_ESCALATION_ENABLED"); ok </span><span class="cov0" title="0">{
                fileCfg.ModelEscalation.Enabled = value
        }</span>

        <span class="cov0" title="0">if retryEnabled </span><span class="cov0" title="0">{
                if !retryJitterSet </span><span class="cov0" title="0">{
                        retryJitter = true
                }</span>
                <span class="cov0" title="0">if len(retryMatch) == 0 </span><span class="cov0" title="0">{
                        retryMatch = append([]string(nil), defaultRetryMatch...)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")
        fmt.Printf("Mode:   %s\n", cfg.mode)
        fmt.Printf("Prompt: %s\n", cfg.promptFile)
        if gitAvailable </span><span class="cov0" title="0">{
                fmt.Printf("Branch: %s\n", branch)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Git:    disabled (workspace fingerprint mode)")
        }</span>
        <span class="cov0" title="0">if cfg.maxIterations &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Max:    %d iterations\n", cfg.maxIterations)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Harness: %s\n", harness)
        if runtime != "" &amp;&amp; runtime != "host" </span><span class="cov0" title="0">{
                fmt.Printf("Runtime: %s\n", runtime)
                if dockerImage != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Docker:  %s\n", dockerImage)
                }</span>
                <span class="cov0" title="0">if dockerContainer != "" </span><span class="cov0" title="0">{
                        fmt.Printf("Container: %s\n", dockerContainer)
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("OnVerifyFail: %s\n", onVerifyFail)
        fmt.Printf("VerifyMissing: %s\n", normalizeVerifyMissingPolicy(fileCfg))
        fmt.Printf("RequireVerifyOnChange: %t\n", fileCfg.RequireVerifyOnChange)
        fmt.Printf("RequireVerifyForPlanUpdate: %t\n", fileCfg.RequireVerifyForPlanUpdate)
        strategyActive := len(fileCfg.Strategy) &gt; 0 &amp;&amp; !cfg.explicitMode
        fmt.Printf("Strategy: %t\n", strategyActive)
        if retryEnabled </span><span class="cov0" title="0">{
                fmt.Printf("Retry:  enabled (max %d, base %s, max %s)\n", retryMaxAttempts, retryBackoffBase, retryBackoffMax)
        }</span>
        <span class="cov0" title="0">fmt.Println("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")

        if _, err := os.Stat(cfg.promptFile); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %s not found\n", cfg.promptFile)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if hasAgentsPlaceholders("AGENTS.md") </span><span class="cov0" title="0">{
                fmt.Println("Warning: AGENTS.md still has placeholder commands. Update it before running build.")
        }</span>

        <span class="cov0" title="0">state := loadState()
        dockerArgsList, err := splitArgs(dockerArgs)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">runner := runtimeExec{
                Runtime:         runtime,
                DockerImage:     dockerImage,
                DockerArgs:      dockerArgsList,
                DockerContainer: dockerContainer,
        }

        if len(fileCfg.Strategy) &gt; 0 &amp;&amp; !cfg.explicitMode </span><span class="cov0" title="0">{
                runStrategy(cfg, fileCfg, runner, state, gitAvailable, branch, planPath, harness, harnessArgs, noPush, logDir, retryEnabled, retryMaxAttempts, retryBackoffBase, retryBackoffMax, retryJitter, retryMatch)
                return
        }</span>

        <span class="cov0" title="0">runMode(cfg, fileCfg, runner, state, gitAvailable, branch, planPath, harness, harnessArgs, noPush, logDir, retryEnabled, retryMaxAttempts, retryBackoffBase, retryBackoffMax, retryJitter, retryMatch, 0)</span>
}

func parseArgs(args []string) (modeConfig, error) <span class="cov8" title="1">{
        cfg := modeConfig{
                mode:          "build",
                promptFile:    "PROMPT_build.md",
                maxIterations: 0,
                forceInit:     false,
                dryRunInit:    false,
                importStage:   "requirements",
                importSlug:    "",
                importDir:     ".specfirst",
                importForce:   false,
                planPath:      "IMPLEMENTATION_PLAN.md",
                explicitMode:  false,
        }

        if len(args) == 0 </span><span class="cov8" title="1">{
                return cfg, nil
        }</span>

        <span class="cov8" title="1">switch args[0] </span>{
        case "--help", "-h", "help":<span class="cov8" title="1">
                cfg.mode = "help"
                return cfg, nil</span>
        case "--version", "version":<span class="cov8" title="1">
                cfg.mode = "version"
                return cfg, nil</span>
        case "import":<span class="cov8" title="1">
                cfg.mode = "import"
                if err := parseImportArgs(args[1:], &amp;cfg); err != nil </span><span class="cov0" title="0">{
                        return cfg, err
                }</span>
                <span class="cov8" title="1">return cfg, nil</span>
        case "init":<span class="cov8" title="1">
                cfg.mode = "init"
                if len(args) &gt; 1 </span><span class="cov8" title="1">{
                        for _, flag := range args[1:] </span><span class="cov8" title="1">{
                                switch flag </span>{
                                case "--force":<span class="cov8" title="1">
                                        cfg.forceInit = true</span>
                                case "--dry-run":<span class="cov8" title="1">
                                        cfg.dryRunInit = true</span>
                                default:<span class="cov0" title="0">
                                        return cfg, fmt.Errorf("unknown init flag: %q", flag)</span>
                                }
                        }
                }
                <span class="cov8" title="1">return cfg, nil</span>
        case "plan-work":<span class="cov0" title="0">
                cfg.mode = "plan-work"
                if len(args) &lt; 2 </span><span class="cov0" title="0">{
                        return cfg, fmt.Errorf("plan-work requires a name")
                }</span>
                <span class="cov0" title="0">cfg.planWorkName = strings.Join(args[1:], " ")
                return cfg, nil</span>
        case "architect":<span class="cov8" title="1">
                cfg.mode = "architect"
                cfg.promptFile = "PROMPT_architect.md"
                cfg.maxIterations = defaultArchitectIterations
                cfg.explicitMode = true // Explicit mode name disables strategy
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        max, err := parsePositiveInt(args[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return cfg, err
                        }</span>
                        <span class="cov0" title="0">cfg.maxIterations = max</span>
                }
        case "plan":<span class="cov8" title="1">
                cfg.mode = "plan"
                cfg.promptFile = "PROMPT_plan.md"
                cfg.maxIterations = defaultPlanIterations
                cfg.explicitMode = true // Explicit mode name disables strategy
                if len(args) &gt; 1 </span><span class="cov8" title="1">{
                        max, err := parsePositiveInt(args[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return cfg, err
                        }</span>
                        <span class="cov8" title="1">cfg.maxIterations = max</span>
                }
        default:<span class="cov8" title="1">
                max, err := parsePositiveInt(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return cfg, fmt.Errorf("invalid mode or max iterations: %q", args[0])
                }</span>
                <span class="cov8" title="1">cfg.mode = "build"
                cfg.promptFile = "PROMPT_build.md"
                cfg.maxIterations = max</span>
                // Note: explicitMode stays false for numeric-only args like "rauf 5"
                // so strategy mode can still apply if configured
        }

        <span class="cov8" title="1">return cfg, nil</span>
}

func parsePositiveInt(input string) (int, error) <span class="cov8" title="1">{
        value, err := strconv.Atoi(input)
        if err != nil || value &lt; 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid numeric value: %q", input)
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

func parseImportArgs(args []string, cfg *modeConfig) error <span class="cov8" title="1">{
        for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                arg := args[i]
                switch arg </span>{
                case "--stage":<span class="cov8" title="1">
                        i++
                        if i &gt;= len(args) </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing value for --stage")
                        }</span>
                        <span class="cov8" title="1">cfg.importStage = args[i]</span>
                case "--slug":<span class="cov8" title="1">
                        i++
                        if i &gt;= len(args) </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing value for --slug")
                        }</span>
                        <span class="cov8" title="1">cfg.importSlug = args[i]</span>
                case "--specfirst-dir":<span class="cov0" title="0">
                        i++
                        if i &gt;= len(args) </span><span class="cov0" title="0">{
                                return fmt.Errorf("missing value for --specfirst-dir")
                        }</span>
                        <span class="cov0" title="0">cfg.importDir = args[i]</span>
                case "--force":<span class="cov0" title="0">
                        cfg.importForce = true</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unknown import flag: %q", arg)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func loadConfig(path string) (runtimeConfig, bool, error) <span class="cov8" title="1">{
        cfg := runtimeConfig{
                RetryMaxAttempts:    3,
                RetryBackoffBase:    2 * time.Second,
                RetryBackoffMax:     30 * time.Second,
                RetryJitter:         true,
                RetryMatch:          append([]string(nil), defaultRetryMatch...),
                NoProgressIters:     2,
                OnVerifyFail:        "soft_reset",
                VerifyMissingPolicy: "strict",
                PlanLintPolicy:      "warn",
                ModelFlag:           "--model",
                ModelEscalation:     defaultEscalationConfig(),
        }
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return cfg, false, nil
                }</span>
                <span class="cov0" title="0">return cfg, false, fmt.Errorf("failed to read %s: %w", path, err)</span>
        }

        <span class="cov8" title="1">if err := parseConfigBytes(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return cfg, true, fmt.Errorf("failed to parse %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">return cfg, true, nil</span>
}

func parseConfigBytes(data []byte, cfg *runtimeConfig) error <span class="cov8" title="1">{
        scanner := bufio.NewScanner(strings.NewReader(string(data)))
        section := ""
        strategyCurrentIdx := -1 // Index into cfg.Strategy, -1 means none
        var inForbiddenPaths bool
        var skipMultilineKey string // Track if we're skipping multi-line content
        var multilineIndent int     // Track the base indent of the multi-line key
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                trimmed := strings.TrimSpace(line)
                if trimmed == "" || strings.HasPrefix(trimmed, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">indent := len(line) - len(strings.TrimLeft(line, " \t"))

                // If we're in a multi-line skip mode, check if we should exit
                if skipMultilineKey != "" </span><span class="cov0" title="0">{
                        // Multi-line content ends when we see a line with equal or less indent than the key
                        if indent &lt;= multilineIndent &amp;&amp; trimmed != "" </span><span class="cov0" title="0">{
                                skipMultilineKey = ""
                                multilineIndent = 0
                                // Fall through to process this line normally
                        }</span> else<span class="cov0" title="0"> {
                                // Still in multi-line content, skip this line
                                continue</span>
                        }
                }

                <span class="cov8" title="1">key, value, ok := splitYAMLKeyValue(trimmed)
                if ok </span><span class="cov8" title="1">{
                        // Check for multi-line YAML syntax which is not supported
                        if value == "|" || value == "&gt;" || value == "|-" || value == "&gt;-" || value == "|+" || value == "&gt;+" </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: rauf.yaml key %q uses multi-line YAML syntax which is not supported; use a single-line value or quoted string instead\n", key)
                                skipMultilineKey = key
                                multilineIndent = indent
                                continue</span>
                        }
                        <span class="cov8" title="1">value = stripQuotesAndComments(value)</span>
                }

                <span class="cov8" title="1">if indent == 0 </span><span class="cov8" title="1">{
                        section = ""
                        strategyCurrentIdx = -1
                        inForbiddenPaths = false
                        if ok &amp;&amp; value == "" </span><span class="cov8" title="1">{
                                section = key
                                continue</span>
                        }
                        <span class="cov8" title="1">switch key </span>{
                        case "harness":<span class="cov8" title="1">
                                cfg.Harness = value</span>
                        case "harness_args":<span class="cov8" title="1">
                                cfg.HarnessArgs = value</span>
                        case "no_push":<span class="cov8" title="1">
                                if v, ok := parseBool(value); ok </span><span class="cov8" title="1">{
                                        cfg.NoPush = v
                                }</span>
                        case "log_dir":<span class="cov8" title="1">
                                cfg.LogDir = value</span>
                        case "runtime":<span class="cov8" title="1">
                                cfg.Runtime = value</span>
                        case "docker_image":<span class="cov8" title="1">
                                cfg.DockerImage = value</span>
                        case "docker_args":<span class="cov0" title="0">
                                cfg.DockerArgs = value</span>
                        case "docker_container":<span class="cov0" title="0">
                                cfg.DockerContainer = value</span>
                        case "max_files_changed":<span class="cov0" title="0">
                                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                                        cfg.MaxFilesChanged = v
                                }</span>
                        case "max_commits_per_iteration":<span class="cov0" title="0">
                                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                                        cfg.MaxCommits = v
                                }</span>
                        case "forbidden_paths":<span class="cov0" title="0">
                                if value == "" </span><span class="cov0" title="0">{
                                        section = "forbidden_paths"
                                        inForbiddenPaths = true
                                }</span> else<span class="cov0" title="0"> {
                                        cfg.ForbiddenPaths = splitCommaList(value)
                                }</span>
                        case "no_progress_iterations":<span class="cov0" title="0">
                                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                                        cfg.NoProgressIters = v
                                }</span>
                        case "on_verify_fail":<span class="cov0" title="0">
                                cfg.OnVerifyFail = value</span>
                        case "verify_missing_policy":<span class="cov0" title="0">
                                cfg.VerifyMissingPolicy = value</span>
                        case "allow_verify_fallback":<span class="cov0" title="0">
                                if v, ok := parseBool(value); ok </span><span class="cov0" title="0">{
                                        cfg.AllowVerifyFallback = v
                                }</span>
                        case "require_verify_on_change":<span class="cov0" title="0">
                                if v, ok := parseBool(value); ok </span><span class="cov0" title="0">{
                                        cfg.RequireVerifyOnChange = v
                                }</span>
                        case "require_verify_for_plan_update":<span class="cov0" title="0">
                                if v, ok := parseBool(value); ok </span><span class="cov0" title="0">{
                                        cfg.RequireVerifyForPlanUpdate = v
                                }</span>
                        case "retry_on_failure":<span class="cov8" title="1">
                                if v, ok := parseBool(value); ok </span><span class="cov8" title="1">{
                                        cfg.RetryOnFailure = v
                                }</span>
                        case "retry_max_attempts":<span class="cov8" title="1">
                                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov8" title="1">{
                                        cfg.RetryMaxAttempts = v
                                }</span>
                        case "retry_backoff_base":<span class="cov8" title="1">
                                if v, err := time.ParseDuration(value); err == nil </span><span class="cov8" title="1">{
                                        cfg.RetryBackoffBase = v
                                }</span>
                        case "retry_backoff_max":<span class="cov8" title="1">
                                if v, err := time.ParseDuration(value); err == nil </span><span class="cov8" title="1">{
                                        cfg.RetryBackoffMax = v
                                }</span>
                        case "retry_jitter":<span class="cov8" title="1">
                                if v, ok := parseBool(value); ok </span><span class="cov8" title="1">{
                                        cfg.RetryJitter = v
                                        cfg.RetryJitterSet = true
                                }</span>
                        case "retry_match":<span class="cov8" title="1">
                                cfg.RetryMatch = splitCommaList(value)</span>
                        case "plan_lint_policy":<span class="cov0" title="0">
                                cfg.PlanLintPolicy = value</span>
                        case "model_default":<span class="cov0" title="0">
                                cfg.ModelDefault = value</span>
                        case "model_strong":<span class="cov0" title="0">
                                cfg.ModelStrong = value</span>
                        case "model_flag":<span class="cov0" title="0">
                                cfg.ModelFlag = value</span>
                        case "model_escalation":<span class="cov0" title="0">
                                section = "model_escalation"</span>
                        case "strategy":<span class="cov0" title="0">
                                section = "strategy"</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if section == "model_escalation" </span><span class="cov8" title="1">{
                        switch key </span>{
                        case "enabled":<span class="cov8" title="1">
                                if v, ok := parseBool(value); ok </span><span class="cov8" title="1">{
                                        cfg.ModelEscalation.Enabled = v
                                }</span>
                        case "cooldown_iters":<span class="cov8" title="1">
                                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov8" title="1">{
                                        cfg.ModelEscalation.CooldownIters = v
                                }</span>
                        case "max_escalations":<span class="cov8" title="1">
                                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov8" title="1">{
                                        cfg.ModelEscalation.MaxEscalations = v
                                }</span>
                        case "trigger":<span class="cov8" title="1"></span>
                                // Nested trigger section - handled below
                        case "consecutive_verify_fails":<span class="cov8" title="1">
                                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov8" title="1">{
                                        cfg.ModelEscalation.ConsecutiveVerifyFails = v
                                }</span>
                        case "no_progress_iters":<span class="cov0" title="0">
                                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                                        cfg.ModelEscalation.NoProgressIters = v
                                }</span>
                        case "guardrail_failures":<span class="cov0" title="0">
                                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                                        cfg.ModelEscalation.GuardrailFailures = v
                                }</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov0" title="0">if section == "forbidden_paths" &amp;&amp; inForbiddenPaths </span><span class="cov0" title="0">{
                        if strings.HasPrefix(trimmed, "-") </span><span class="cov0" title="0">{
                                item := strings.TrimSpace(strings.TrimPrefix(trimmed, "-"))
                                item = stripQuotes(item)
                                if item != "" </span><span class="cov0" title="0">{
                                        cfg.ForbiddenPaths = append(cfg.ForbiddenPaths, item)
                                }</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">if section == "strategy" </span><span class="cov0" title="0">{
                        if strings.HasPrefix(trimmed, "-") </span><span class="cov0" title="0">{
                                step := strategyStep{}
                                rest := strings.TrimSpace(strings.TrimPrefix(trimmed, "-"))
                                if rest != "" </span><span class="cov0" title="0">{
                                        if k, v, ok := splitYAMLKeyValue(rest); ok </span><span class="cov0" title="0">{
                                                assignStrategyField(&amp;step, k, stripQuotes(v))
                                        }</span>
                                }
                                <span class="cov0" title="0">cfg.Strategy = append(cfg.Strategy, step)
                                strategyCurrentIdx = len(cfg.Strategy) - 1
                                continue</span>
                        }
                        <span class="cov0" title="0">if strategyCurrentIdx &gt;= 0 &amp;&amp; ok </span><span class="cov0" title="0">{
                                assignStrategyField(&amp;cfg.Strategy[strategyCurrentIdx], key, value)
                        }</span>
                }
        }

        <span class="cov8" title="1">return scanner.Err()</span>
}

func assignStrategyField(step *strategyStep, key, value string) <span class="cov0" title="0">{
        switch key </span>{
        case "mode":<span class="cov0" title="0">
                step.Mode = value</span>
        case "iterations":<span class="cov0" title="0">
                if v, err := strconv.Atoi(value); err == nil &amp;&amp; v &gt;= 0 </span><span class="cov0" title="0">{
                        step.Iterations = v
                }</span>
        case "until":<span class="cov0" title="0">
                step.Until = value</span>
        case "if":<span class="cov0" title="0">
                step.If = value</span>
        }
}

func splitYAMLKeyValue(line string) (string, string, bool) <span class="cov8" title="1">{
        parts := strings.SplitN(line, ":", 2)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return "", "", false
        }</span>
        <span class="cov8" title="1">key := strings.TrimSpace(parts[0])
        value := strings.TrimSpace(parts[1])
        return key, value, true</span>
}

// stripQuotesAndComments removes surrounding quotes and trailing inline comments.
// Inline comments start with # when not inside quotes.
func stripQuotesAndComments(value string) string <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return value
        }</span>

        // If quoted, extract the quoted content (handles embedded #)
        <span class="cov8" title="1">if len(value) &gt;= 2 </span><span class="cov8" title="1">{
                if (value[0] == '"' &amp;&amp; value[len(value)-1] == '"') ||
                        (value[0] == '\'' &amp;&amp; value[len(value)-1] == '\'') </span><span class="cov8" title="1">{
                        return value[1 : len(value)-1]
                }</span>
                // Check for quote at start with comment after closing quote
                // Handle escaped quotes within the string
                <span class="cov8" title="1">if value[0] == '"' || value[0] == '\'' </span><span class="cov0" title="0">{
                        quote := value[0]
                        escaped := false
                        for i := 1; i &lt; len(value); i++ </span><span class="cov0" title="0">{
                                if escaped </span><span class="cov0" title="0">{
                                        escaped = false
                                        continue</span>
                                }
                                <span class="cov0" title="0">if value[i] == '\\' </span><span class="cov0" title="0">{
                                        escaped = true
                                        continue</span>
                                }
                                <span class="cov0" title="0">if value[i] == quote </span><span class="cov0" title="0">{
                                        return value[1:i]
                                }</span>
                        }
                }
        }

        // Unquoted value: strip inline comment
        <span class="cov8" title="1">if idx := strings.Index(value, " #"); idx &gt;= 0 </span><span class="cov0" title="0">{
                value = strings.TrimSpace(value[:idx])
        }</span>

        <span class="cov8" title="1">return value</span>
}

func stripQuotes(value string) string <span class="cov8" title="1">{
        if len(value) &lt; 2 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov8" title="1">if (value[0] == '"' &amp;&amp; value[len(value)-1] == '"') || (value[0] == '\'' &amp;&amp; value[len(value)-1] == '\'') </span><span class="cov8" title="1">{
                return value[1 : len(value)-1]
        }</span>
        <span class="cov8" title="1">return value</span>
}

func parseBool(value string) (bool, bool) <span class="cov8" title="1">{
        switch strings.ToLower(strings.TrimSpace(value)) </span>{
        case "1", "true", "yes", "y", "on":<span class="cov8" title="1">
                return true, true</span>
        case "0", "false", "no", "n", "off":<span class="cov8" title="1">
                return false, true</span>
        default:<span class="cov0" title="0">
                return false, false</span>
        }
}

func runHarness(ctx context.Context, prompt string, harness, harnessArgs string, logFile *os.File, retry retryConfig, runner runtimeExec) (harnessResult, error) <span class="cov8" title="1">{
        attempts := 0
        matchedToken := ""
        for </span><span class="cov8" title="1">{
                output, err := runHarnessOnce(ctx, prompt, harness, harnessArgs, logFile, runner)
                if err == nil </span><span class="cov8" title="1">{
                        return harnessResult{Output: output, RetryCount: attempts, RetryReason: matchedToken}, nil
                }</span>
                <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return harnessResult{Output: output, RetryCount: attempts, RetryReason: matchedToken}, err
                }</span>
                <span class="cov0" title="0">if !retry.Enabled || retry.MaxAttempts == 0 </span><span class="cov0" title="0">{
                        return harnessResult{Output: output, RetryCount: attempts, RetryReason: matchedToken}, err
                }</span>
                <span class="cov0" title="0">token, shouldRetry := retryMatchToken(output, retry.Match)
                if !shouldRetry </span><span class="cov0" title="0">{
                        return harnessResult{Output: output, RetryCount: attempts, RetryReason: matchedToken}, err
                }</span>
                <span class="cov0" title="0">matchedToken = token
                if attempts &gt;= retry.MaxAttempts </span><span class="cov0" title="0">{
                        return harnessResult{Output: output, RetryCount: attempts, RetryReason: matchedToken}, err
                }</span>
                <span class="cov0" title="0">attempts++
                delay := backoffDuration(retry.BackoffBase, retry.BackoffMax, attempts, retry.Jitter)
                fmt.Fprintf(os.Stderr, "Harness error matched retry rule (%s); sleeping %s before retry %d/%d\n", token, delay, attempts, retry.MaxAttempts)
                timer := time.NewTimer(delay)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        timer.Stop()
                        return harnessResult{Output: output, RetryCount: attempts, RetryReason: matchedToken}, ctx.Err()</span>
                case &lt;-timer.C:<span class="cov0" title="0"></span>
                }
        }
}

func runHarnessOnce(ctx context.Context, prompt string, harness, harnessArgs string, logFile *os.File, runner runtimeExec) (string, error) <span class="cov8" title="1">{
        args := []string{}
        if harnessArgs != "" </span><span class="cov8" title="1">{
                extraArgs, err := splitArgs(harnessArgs)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">args = append(args, extraArgs...)</span>
        }

        <span class="cov8" title="1">buffer := &amp;limitedBuffer{max: 8 * 1024}

        cmd, err := runner.command(ctx, harness, args...)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">cmd.Stdin = strings.NewReader(prompt)
        cmd.Stdout = io.MultiWriter(os.Stdout, logFile, buffer)
        cmd.Stderr = io.MultiWriter(os.Stderr, logFile, buffer)
        cmd.Env = os.Environ()

        return buffer.String(), cmd.Run()</span>
}

func openLogFile(mode string, logDir string) (*os.File, string, error) <span class="cov8" title="1">{
        if logDir == "" </span><span class="cov0" title="0">{
                logDir = "logs"
        }</span>
        <span class="cov8" title="1">if err := os.MkdirAll(logDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">now := time.Now()
        stamp := now.Format("20060102-150405.000000000")
        path := filepath.Join(logDir, fmt.Sprintf("%s-%s.jsonl", mode, stamp))
        file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov8" title="1">return file, path, nil</span>
}

func gitOutput(args ...string) (string, error) <span class="cov0" title="0">{
        output, err := gitOutputRaw(args...)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(output), nil</span>
}

func gitOutputRaw(args ...string) (string, error) <span class="cov8" title="1">{
        cmd := exec.Command("git", args...)
        cmd.Env = os.Environ()
        var out bytes.Buffer
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;out
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return out.String(), nil</span>
}

func gitPush(branch string) error <span class="cov0" title="0">{
        cmd := exec.Command("git", "push", "origin", branch)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.Env = os.Environ()
        if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // First push failed, try with -u flag to set upstream
        <span class="cov0" title="0">fmt.Println("Initial push failed, retrying with upstream tracking...")
        fallback := exec.Command("git", "push", "-u", "origin", branch)
        fallback.Stdout = os.Stdout
        fallback.Stderr = os.Stderr
        fallback.Env = os.Environ()
        if err := fallback.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("git push failed: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func isCleanWorkingTree() bool <span class="cov0" title="0">{
        if err := gitQuiet("diff", "--quiet"); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if err := gitQuiet("diff", "--cached", "--quiet"); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func gitQuiet(args ...string) error <span class="cov0" title="0">{
        cmd := exec.Command("git", args...)
        cmd.Env = os.Environ()
        return cmd.Run()
}</span>

func hasPlanFile(path string) bool <span class="cov8" title="1">{
        _, err := os.Stat(path)
        return err == nil
}</span>

func hasUncheckedTasks(path string) bool <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">defer file.Close()

        taskLine := regexp.MustCompile(`^\s*[-*]\s+\[\s\]\s+`)
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                if taskLine.MatchString(scanner.Text()) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func fileHash(path string) string <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">sum := sha256.Sum256(data)
        return fmt.Sprintf("%x", sum)</span>
}

func workspaceFingerprint(root string, excludeDirs []string, excludeFiles []string) string <span class="cov8" title="1">{
        hasher := sha256.New()
        excludeDirAbs := make([]string, 0, len(excludeDirs))
        for _, dir := range excludeDirs </span><span class="cov8" title="1">{
                dir = strings.TrimSpace(dir)
                if dir == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if !filepath.IsAbs(dir) </span><span class="cov8" title="1">{
                        dir = filepath.Join(root, dir)
                }</span>
                <span class="cov8" title="1">excludeDirAbs = append(excludeDirAbs, filepath.Clean(dir))</span>
        }
        <span class="cov8" title="1">excludeFileAbs := make(map[string]struct{}, len(excludeFiles))
        for _, file := range excludeFiles </span><span class="cov0" title="0">{
                file = strings.TrimSpace(file)
                if file == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if !filepath.IsAbs(file) </span><span class="cov0" title="0">{
                        file = filepath.Join(root, file)
                }</span>
                <span class="cov0" title="0">excludeFileAbs[filepath.Clean(file)] = struct{}{}</span>
        }

        <span class="cov8" title="1">_ = filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">cleanPath := filepath.Clean(path)
                if _, ok := excludeFileAbs[cleanPath]; ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">for _, dir := range excludeDirAbs </span><span class="cov8" title="1">{
                        if cleanPath == dir || strings.HasPrefix(cleanPath, dir+string(filepath.Separator)) </span><span class="cov8" title="1">{
                                if d.IsDir() </span><span class="cov8" title="1">{
                                        return filepath.SkipDir
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }
                }
                <span class="cov8" title="1">if d.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">_, _ = hasher.Write([]byte(path))
                _, _ = hasher.Write(data)
                return nil</span>
        })
        <span class="cov8" title="1">return fmt.Sprintf("%x", hasher.Sum(nil))</span>
}

func printUsage() <span class="cov0" title="0">{
        fmt.Println("Usage:")
        fmt.Println("  rauf init [--force] [--dry-run]")
        fmt.Println("  rauf import [--stage &lt;id&gt;] [--slug &lt;slug&gt;] [--specfirst-dir &lt;path&gt;] [--force]")
        fmt.Println("  rauf plan-work \"&lt;name&gt;\"")
        fmt.Println("  rauf [architect|plan|&lt;max_iterations&gt;]")
        fmt.Println("")
        fmt.Println("Examples:")
        fmt.Println("  rauf")
        fmt.Println("  rauf 20")
        fmt.Println("  rauf plan")
        fmt.Println("  rauf plan 3")
        fmt.Println("  rauf architect")
        fmt.Println("  rauf architect 5")
        fmt.Println("  rauf import --stage requirements --slug user-auth")
        fmt.Println("  rauf plan-work \"add oauth\"")
        fmt.Println("")
        fmt.Println("Env:")
        fmt.Println("  RAUF_HARNESS=claude     Harness command (default: claude)")
        fmt.Println("  RAUF_HARNESS_ARGS=...   Extra harness args")
        fmt.Println("  RAUF_NO_PUSH=1          Skip git push even if new commits exist")
        fmt.Println("  RAUF_LOG_DIR=path       Override logs directory")
        fmt.Println("  RAUF_RUNTIME=host|docker|docker-persist Runtime execution target")
        fmt.Println("  RAUF_DOCKER_IMAGE=image  Docker image for docker runtimes")
        fmt.Println("  RAUF_DOCKER_ARGS=...     Extra args for docker run")
        fmt.Println("  RAUF_DOCKER_CONTAINER=name  Container name for docker-persist")
        fmt.Println("  RAUF_ON_VERIFY_FAIL=mode  soft_reset|keep_commit|hard_reset|no_push_only|wip_branch")
        fmt.Println("  RAUF_VERIFY_MISSING_POLICY=mode  strict|agent_enforced|fallback")
        fmt.Println("  RAUF_ALLOW_VERIFY_FALLBACK=1  Allow AGENTS.md Verify fallback")
        fmt.Println("  RAUF_REQUIRE_VERIFY_ON_CHANGE=1  Require Verify when worktree changes")
        fmt.Println("  RAUF_REQUIRE_VERIFY_FOR_PLAN_UPDATE=1  Require Verify before plan updates")
        fmt.Println("  RAUF_RETRY=1            Retry harness failures (matches only)")
        fmt.Println("  RAUF_RETRY_MAX=3        Max retry attempts")
        fmt.Println("  RAUF_RETRY_BACKOFF_BASE=2s  Base backoff duration")
        fmt.Println("  RAUF_RETRY_BACKOFF_MAX=30s  Max backoff duration")
        fmt.Println("  RAUF_RETRY_NO_JITTER=1  Disable backoff jitter")
        fmt.Println("  RAUF_RETRY_MATCH=...    Comma-separated match tokens")
}</span>

func envFirst(keys ...string) string <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                if value := os.Getenv(key); value != "" </span><span class="cov8" title="1">{
                        return value
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func envBool(keys ...string) (bool, bool) <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                if value, ok := os.LookupEnv(key); ok </span><span class="cov8" title="1">{
                        result, valid := parseBool(value)
                        if !valid </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: invalid boolean value %q for %s, ignoring\n", value, key)
                        }</span>
                        <span class="cov8" title="1">return result, valid</span>
                }
        }
        <span class="cov0" title="0">return false, false</span>
}

func splitCommaList(value string) []string <span class="cov8" title="1">{
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.Split(value, ",")
        items := make([]string, 0, len(parts))
        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.TrimSpace(part)
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">items = append(items, part)</span>
        }
        <span class="cov8" title="1">return items</span>
}

func splitArgs(value string) ([]string, error) <span class="cov8" title="1">{
        if strings.TrimSpace(value) == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">fields := []string{}
        current := strings.Builder{}
        inQuote := rune(0)
        escaped := false
        for _, r := range value </span><span class="cov8" title="1">{
                switch </span>{
                case escaped:<span class="cov8" title="1">
                        current.WriteRune(r)
                        escaped = false</span>
                case r == '\\':<span class="cov8" title="1">
                        escaped = true</span>
                case inQuote != 0:<span class="cov8" title="1">
                        if r == inQuote </span><span class="cov8" title="1">{
                                inQuote = 0
                        }</span> else<span class="cov8" title="1"> {
                                current.WriteRune(r)
                        }</span>
                case r == '"' || r == '\'':<span class="cov8" title="1">
                        inQuote = r</span>
                case r == ' ' || r == '\t':<span class="cov8" title="1">
                        if current.Len() &gt; 0 </span><span class="cov8" title="1">{
                                fields = append(fields, current.String())
                                current.Reset()
                        }</span>
                default:<span class="cov8" title="1">
                        current.WriteRune(r)</span>
                }
        }
        <span class="cov8" title="1">if escaped </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid args: unfinished escape")
        }</span>
        <span class="cov8" title="1">if inQuote != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid args: unterminated quote")
        }</span>
        <span class="cov8" title="1">if current.Len() &gt; 0 </span><span class="cov8" title="1">{
                fields = append(fields, current.String())
        }</span>
        <span class="cov8" title="1">return fields, nil</span>
}

type limitedBuffer struct {
        buf []byte
        max int
}

func (b *limitedBuffer) Write(p []byte) (int, error) <span class="cov0" title="0">{
        if b.max &lt;= 0 </span><span class="cov0" title="0">{
                return len(p), nil
        }</span>
        <span class="cov0" title="0">if len(p) &gt;= b.max </span><span class="cov0" title="0">{
                b.buf = make([]byte, b.max)
                copy(b.buf, p[len(p)-b.max:])
                return len(p), nil
        }</span>
        <span class="cov0" title="0">if len(b.buf)+len(p) &gt; b.max </span><span class="cov0" title="0">{
                drop := len(b.buf) + len(p) - b.max
                // Defensive check: ensure drop doesn't exceed buffer length
                if drop &gt; len(b.buf) </span><span class="cov0" title="0">{
                        drop = len(b.buf)
                }</span>
                <span class="cov0" title="0">if drop &lt; 0 </span><span class="cov0" title="0">{
                        drop = 0
                }</span>
                <span class="cov0" title="0">remaining := len(b.buf) - drop
                if remaining &lt; 0 </span><span class="cov0" title="0">{
                        remaining = 0
                }</span>
                // Create a new slice to avoid retaining old backing array memory
                <span class="cov0" title="0">newBuf := make([]byte, remaining, b.max)
                if remaining &gt; 0 </span><span class="cov0" title="0">{
                        copy(newBuf, b.buf[drop:])
                }</span>
                <span class="cov0" title="0">b.buf = newBuf</span>
        }
        <span class="cov0" title="0">b.buf = append(b.buf, p...)
        return len(p), nil</span>
}

func (b *limitedBuffer) String() string <span class="cov8" title="1">{
        return string(b.buf)
}</span>

func retryMatchToken(output string, match []string) (string, bool) <span class="cov8" title="1">{
        if len(match) == 0 </span><span class="cov8" title="1">{
                return "", false
        }</span>
        <span class="cov8" title="1">lower := strings.ToLower(output)
        for _, token := range match </span><span class="cov8" title="1">{
                token = strings.TrimSpace(token)
                if token == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if token == "*" </span><span class="cov8" title="1">{
                        return "*", true
                }</span>
                <span class="cov8" title="1">if strings.Contains(lower, strings.ToLower(token)) </span><span class="cov8" title="1">{
                        return token, true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

func backoffDuration(base, max time.Duration, attempt int, jitter bool) time.Duration <span class="cov8" title="1">{
        if base &lt;= 0 </span><span class="cov0" title="0">{
                base = 2 * time.Second
        }</span>
        <span class="cov8" title="1">if attempt &lt; 1 </span><span class="cov0" title="0">{
                attempt = 1
        }</span>
        // Cap the shift to prevent integer overflow (max 62 for int64)
        <span class="cov8" title="1">shift := attempt - 1
        if shift &gt; 62 </span><span class="cov8" title="1">{
                shift = 62
        }</span>
        <span class="cov8" title="1">delay := base * time.Duration(1&lt;&lt;uint(shift))
        if max &gt; 0 &amp;&amp; delay &gt; max </span><span class="cov0" title="0">{
                delay = max
        }</span>
        <span class="cov8" title="1">if jitter </span><span class="cov0" title="0">{
                delay = jitterDuration(delay)
        }</span>
        <span class="cov8" title="1">return delay</span>
}

func jitterDuration(delay time.Duration) time.Duration <span class="cov0" title="0">{
        if delay &lt;= 0 </span><span class="cov0" title="0">{
                return delay
        }</span>
        <span class="cov0" title="0">jitterMu.Lock()
        factor := 0.5 + jitterRng.Float64()
        jitterMu.Unlock()
        return time.Duration(float64(delay) * factor)</span>
}

func runInit(force bool, dryRun bool) error <span class="cov8" title="1">{
        type templateFile struct {
                path    string
                content string
        }

        files := []templateFile{
                {path: "rauf.yaml", content: configTemplate},
                {path: "PROMPT_architect.md", content: promptArchitect},
                {path: "PROMPT_plan.md", content: promptPlan},
                {path: "PROMPT_build.md", content: promptBuild},
                {path: filepath.Join("specs", "_TEMPLATE.md"), content: specTemplate},
                {path: filepath.Join("specs", "README.md"), content: specReadme},
                {path: "AGENTS.md", content: agentsTemplate},
                {path: "IMPLEMENTATION_PLAN.md", content: planTemplate},
        }

        var created []string
        var skipped []string
        var overwritten []string

        for _, file := range files </span><span class="cov8" title="1">{
                if err := os.MkdirAll(filepath.Dir(file.path), 0o755); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">_, statErr := os.Stat(file.path)
                exists := statErr == nil
                if exists &amp;&amp; !force </span><span class="cov0" title="0">{
                        skipped = append(skipped, file.path)
                        continue</span>
                }
                <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                        if exists </span><span class="cov0" title="0">{
                                overwritten = append(overwritten, file.path)
                        }</span> else<span class="cov8" title="1"> {
                                created = append(created, file.path)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov0" title="0">if err := os.WriteFile(file.path, []byte(file.content), 0o644); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        overwritten = append(overwritten, file.path)
                }</span> else<span class="cov0" title="0"> {
                        created = append(created, file.path)
                }</span>
        }

        <span class="cov8" title="1">gitignoreUpdated, err := ensureGitignoreLogs(dryRun)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if gitignoreUpdated </span><span class="cov8" title="1">{
                if dryRun </span><span class="cov8" title="1">{
                        overwritten = append(overwritten, ".gitignore (logs/)")
                }</span> else<span class="cov0" title="0"> {
                        created = append(created, ".gitignore (logs/)")
                }</span>
        }

        <span class="cov8" title="1">if dryRun </span><span class="cov8" title="1">{
                fmt.Println("Init dry run complete.")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Init complete.")
        }</span>
        <span class="cov8" title="1">if len(created) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("Created: %s\n", strings.Join(created, ", "))
        }</span>
        <span class="cov8" title="1">if len(overwritten) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Printf("Overwritten: %s\n", strings.Join(overwritten, ", "))
        }</span>
        <span class="cov8" title="1">if len(skipped) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Skipped: %s\n", strings.Join(skipped, ", "))
        }</span>
        <span class="cov8" title="1">if len(created) == 0 &amp;&amp; len(overwritten) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No files created.")
        }</span>
        <span class="cov8" title="1">if !dryRun </span><span class="cov0" title="0">{
                fmt.Println("Next: update AGENTS.md with repo-specific commands.")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type specfirstState struct {
        StageOutputs map[string]specfirstStageOutput `json:"stage_outputs"`
}

type specfirstStageOutput struct {
        PromptHash string   `json:"prompt_hash"`
        Files      []string `json:"files"`
}

type artifactFile struct {
        name    string
        content string
}

func runImportSpecfirst(cfg modeConfig) error <span class="cov8" title="1">{
        if cfg.importStage == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("stage is required")
        }</span>
        <span class="cov8" title="1">statePath := filepath.Join(cfg.importDir, "state.json")
        stateBytes, err := os.ReadFile(statePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read %s: %w", statePath, err)
        }</span>

        <span class="cov8" title="1">var state specfirstState
        if err := json.Unmarshal(stateBytes, &amp;state); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse %s: %w", statePath, err)
        }</span>

        <span class="cov8" title="1">stageOutput, ok := state.StageOutputs[cfg.importStage]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("stage %q not found in %s", cfg.importStage, statePath)
        }</span>
        <span class="cov8" title="1">if stageOutput.PromptHash == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("stage %q has no prompt hash in %s", cfg.importStage, statePath)
        }</span>
        <span class="cov8" title="1">if len(stageOutput.Files) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("stage %q has no output files in %s", cfg.importStage, statePath)
        }</span>

        <span class="cov8" title="1">slug := cfg.importSlug
        if slug == "" </span><span class="cov8" title="1">{
                slug = slugFromFiles(stageOutput.Files, cfg.importStage)
        }</span>
        <span class="cov8" title="1">slug = slugify(slug)
        if slug == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to derive a valid slug")
        }</span>

        <span class="cov8" title="1">specsDir := "specs"
        if err := os.MkdirAll(specsDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">specPath := filepath.Join(specsDir, slug+".md")
        if _, err := os.Stat(specPath); err == nil &amp;&amp; !cfg.importForce </span><span class="cov0" title="0">{
                return fmt.Errorf("spec file exists: %s (use --force to overwrite)", specPath)
        }</span>

        <span class="cov8" title="1">files, err := readSpecfirstArtifacts(cfg.importDir, cfg.importStage, stageOutput.PromptHash, stageOutput.Files)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">artifactTitle := titleFromArtifacts(files, slug)
        content := buildSpecFromArtifact(slug, artifactTitle, cfg.importStage, stageOutput.PromptHash, files)
        return os.WriteFile(specPath, []byte(content), 0o644)</span>
}

func ensureGitignoreLogs(dryRun bool) (bool, error) <span class="cov8" title="1">{
        const entry = "logs/"
        path := ".gitignore"
        data, err := os.ReadFile(path)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if err == nil </span><span class="cov0" title="0">{
                if bytes.Contains(data, []byte(entry)) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
                <span class="cov0" title="0">updated := append(bytes.TrimRight(data, "\n"), []byte("\n"+entry+"\n")...)
                return true, os.WriteFile(path, updated, 0o644)</span>
        }

        <span class="cov8" title="1">content := []byte(entry + "\n")
        if dryRun </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return true, os.WriteFile(path, content, 0o644)</span>
}

func hasAgentsPlaceholders(path string) bool <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">text := string(data)
        placeholders := []string{
                "[test command]",
                "[full test command]",
                "[lint command]",
                "[typecheck/build command]",
        }
        for _, placeholder := range placeholders </span><span class="cov8" title="1">{
                if strings.Contains(text, placeholder) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func readSpecfirstArtifacts(root, stage, hash string, files []string) ([]artifactFile, error) <span class="cov8" title="1">{
        baseDir := filepath.Join(root, "artifacts", stage, hash)
        absBaseDir, err := filepath.Abs(baseDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to resolve artifact base directory: %w", err)
        }</span>
        <span class="cov8" title="1">artifacts := make([]artifactFile, 0, len(files))
        for _, name := range files </span><span class="cov8" title="1">{
                // Validate filename doesn't escape base directory via path traversal
                path := filepath.Join(baseDir, name)
                absPath, err := filepath.Abs(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to resolve artifact path %s: %w", name, err)
                }</span>
                // Ensure resolved path is within the expected directory
                <span class="cov8" title="1">if !strings.HasPrefix(absPath, absBaseDir+string(filepath.Separator)) &amp;&amp; absPath != absBaseDir </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("artifact path %q escapes base directory", name)
                }</span>
                <span class="cov8" title="1">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read artifact %s: %w", path, err)
                }</span>
                <span class="cov8" title="1">artifacts = append(artifacts, artifactFile{name: name, content: string(data)})</span>
        }
        <span class="cov8" title="1">return artifacts, nil</span>
}

func slugFromFiles(files []string, fallback string) string <span class="cov8" title="1">{
        if len(files) == 1 </span><span class="cov8" title="1">{
                base := filepath.Base(files[0])
                ext := filepath.Ext(base)
                return strings.TrimSuffix(base, ext)
        }</span>
        <span class="cov8" title="1">return fallback</span>
}

func slugify(value string) string <span class="cov8" title="1">{
        lower := strings.ToLower(value)
        var b strings.Builder
        prevDash := false
        for _, r := range lower </span><span class="cov8" title="1">{
                switch </span>{
                case r &gt;= 'a' &amp;&amp; r &lt;= 'z':<span class="cov8" title="1">
                        b.WriteRune(r)
                        prevDash = false</span>
                case r &gt;= '0' &amp;&amp; r &lt;= '9':<span class="cov8" title="1">
                        b.WriteRune(r)
                        prevDash = false</span>
                default:<span class="cov8" title="1">
                        if !prevDash </span><span class="cov8" title="1">{
                                b.WriteRune('-')
                                prevDash = true
                        }</span>
                }
        }
        <span class="cov8" title="1">return strings.Trim(b.String(), "-")</span>
}

func titleFromArtifacts(files []artifactFile, fallback string) string <span class="cov8" title="1">{
        for _, file := range files </span><span class="cov8" title="1">{
                lines := strings.Split(file.content, "\n")
                for _, line := range lines </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(line)
                        if strings.HasPrefix(line, "# ") &amp;&amp; len(line) &gt; 2 </span><span class="cov8" title="1">{
                                return strings.TrimSpace(strings.TrimPrefix(line, "# "))
                        }</span>
                }
        }
        <span class="cov0" title="0">return fallback</span>
}

func buildSpecFromArtifact(slug, title, stage, hash string, files []artifactFile) string <span class="cov8" title="1">{
        var b strings.Builder
        b.WriteString("---\n")
        b.WriteString("id: " + slug + "\n")
        b.WriteString("status: draft # draft | approved\n")
        b.WriteString("version: 0.1.0\n")
        b.WriteString("owner: &lt;optional&gt;\n")
        b.WriteString("source: specfirst\n")
        b.WriteString("stage: " + stage + "\n")
        b.WriteString("artifact: " + hash + "\n")
        b.WriteString("---\n\n")
        b.WriteString("# " + title + "\n\n")
        b.WriteString("## 1. Context &amp; User Story\n")
        b.WriteString("Imported from SpecFirst " + stage + " artifact. See Appendix.\n\n")
        b.WriteString("## 2. Non-Goals\n")
        b.WriteString("- TBD\n\n")
        b.WriteString("## 3. Contract (SpecFirst)\n")
        b.WriteString("Contract format: &lt;TypeScript | JSON Schema | OpenAPI | SQL | UI State | CLI | Other&gt;\n\n")
        b.WriteString("TBD\n\n")
        b.WriteString("## 4. Scenarios (Acceptance Criteria)\n")
        b.WriteString("### Scenario: TBD\n")
        b.WriteString("Given ...\n")
        b.WriteString("When ...\n")
        b.WriteString("Then ...\n\n")
        b.WriteString("Verification:\n")
        b.WriteString("- TBD: add harness\n\n")
        b.WriteString("## 5. Constraints / NFRs\n")
        b.WriteString("- Performance: TBD\n")
        b.WriteString("- Security: TBD\n")
        b.WriteString("- Compatibility: TBD\n")
        b.WriteString("- Observability: TBD\n\n")
        b.WriteString("## 6. Open Questions / Assumptions\n")
        b.WriteString("- Assumption: TBD\n")
        b.WriteString("- Open question: TBD\n\n")
        b.WriteString("## Appendix: SpecFirst " + stage + " Artifact\n")
        for _, file := range files </span><span class="cov8" title="1">{
                b.WriteString("\n### " + file.name + "\n\n")
                b.WriteString(strings.TrimRight(file.content, "\n"))
                b.WriteString("\n")
        }</span>
        <span class="cov8" title="1">return b.String()</span>
}

const promptArchitect = `# ROLE: System Architect (Spec-First)

You are acting as a System Architect, not an implementer.

Your sole responsibility is to produce or refine a rigorous specification artifact
that clearly defines WHAT must be built, not HOW it is built.

You MUST NOT:
- Write application code
- Modify implementation files
- Generate an implementation plan
- Attempt to determine whether the spec is already implemented
- Read large portions of the codebase; focus on defining the contract

You MUST:
- Produce or update exactly one spec file under "specs/"
- Follow the template in "specs/_TEMPLATE.md"
- Define contracts before behavior
- Ensure all acceptance criteria are testable

---

## Repo Context (auto-generated)

Repo map (truncated):

{{.RepoMap}}

---

## Phase 0a — Orientation

1. Study "specs/_TEMPLATE.md" carefully. This defines the required structure.
2. Review existing files under "specs/" to avoid overlap or duplication.
3. If present, skim "AGENTS.md" to understand repo conventions (do not act on them).

---

## Phase 0b — Clarification (Interview)

If the user's request is vague or underspecified, ask up to 3 clarifying questions
focused on:
- The interface/contract (inputs, outputs, data shapes, APIs, UI states, etc.)
- The happy path
- The most important edge cases

IMPORTANT:
- Do NOT block indefinitely waiting for answers.
- If answers are missing, proceed using explicit assumptions and record them
  in the spec under "Open Questions / Assumptions".
- Ask questions by emitting lines prefixed with "RAUF_QUESTION:" so the runner can pause.

---

## Phase 1 — Specification Drafting

1. Create or update a file at:
   "specs/&lt;topic-slug&gt;.md"

2. Strictly follow the structure in "specs/_TEMPLATE.md".

3. Contract First Rule (MANDATORY):
   - Section "Contract" MUST be written before scenarios.
   - The contract must define the source-of-truth data shape, API, schema, or UI state.
   - If multiple contract options exist, document them and clearly choose one.

4. Scenario Rule (MANDATORY):
   - Each scenario must be written as Given / When / Then.
   - Each scenario MUST include a "Verification:" subsection.
   - If verification is not yet possible, write:
     "Verification: TBD: add harness"
     (This will become a first-class planning task.)

5. Testability Rule:
   - Every scenario must be objectively verifiable.
   - Avoid subjective outcomes like "works correctly" or "behaves as expected".

6. Set frontmatter:
   - "status: draft" unless the user explicitly approves the spec.

---

## Phase 2 — Review Gate

After writing or updating the spec:

1. Ask the user to review the spec.
2. Clearly state:
   - What assumptions were made
   - What decisions were taken in the contract
3. If the user approves:
   - Update the spec frontmatter to "status: approved"
4. If the user requests changes:
   - Revise the spec ONLY (do not plan or build)

---

## Definition of Done (Architect)

Your task is complete when:
- A single spec exists under "specs/"
- It follows the template
- Contracts are defined
- Scenarios are testable
- Status is either "draft" or "approved"

STOP once this condition is met.
`

const promptPlan = `# ROLE: Planner (Spec → Plan)

You are acting as a Planner.

Your responsibility is to translate approved specifications
into a concrete, ordered implementation plan.

You MUST NOT:
- Write application code
- Modify spec content
- Invent requirements not present in approved specs

You MUST:
- Derive all tasks from approved specs only
- Maintain traceability from plan → spec → verification
- Produce or update "{{.PlanPath}}"

---

## Plan Context (auto-generated)

Approved spec index:

{{.SpecIndex}}

Repo map (truncated):

{{.RepoMap}}

---

## Phase 0a — Orientation

1. Study "AGENTS.md" to understand repo commands and workflow.
2. Study all files under "specs/".

---

## Phase 0b — Spec Selection

1. Identify specs with frontmatter:
   "status: approved"

2. Ignore all specs marked "draft".

If no approved specs exist:
- Create a single plan item:
  "Run architect to produce approved specs"
- STOP.

---

## Phase 1 — Gap Analysis (MANDATORY)

For EACH approved spec:

1. Search the existing codebase to determine:
   - Which parts of the Contract already exist
   - Which Scenarios are already satisfied
   - Which verification mechanisms already exist
2. DO NOT assume anything is missing.
3. Cite specific files/functions/tests that already satisfy parts of the spec.

Only create plan tasks for:
- Gaps between spec and code
- Missing or failing verification
- Incomplete or incorrect behavior

Optionally, include a short "Satisfied by existing code" section in the plan
that lists scenarios already covered and where they live.

---

## Phase 2 — Spec-to-Plan Extraction

For EACH approved spec:

### 1. Contract Tasks
- If the spec defines a Contract:
  - Create tasks to introduce or modify the contract
    (types, schema, API definitions, UI state, etc.)
  - These tasks come BEFORE behavioral tasks.

### 2. Scenario Tasks
For EACH scenario in the spec:
- Create tasks that include:
  a) Creating or updating the verification mechanism (tests, harness, scripts)
  b) Implementing logic to satisfy the scenario

Derive tasks ONLY for gaps identified in Phase 1.

---

## Phase 3 — Plan Authoring

Create or update "{{.PlanPath}}".

Each task MUST include:
- A checkbox "[ ]"
- "Spec:" reference (file + section anchor)
- "Verify:" exact command(s) to run
- "Outcome:" clear observable success condition

Example:

- [ ] T3: Enforce unique user email
  - Spec: specs/user-profile.md#Scenario-duplicate-email
  - Verify: npm test -- user-profile
  - Outcome: duplicate email creation fails with 409

---

## Phase 4 — Plan Hygiene

- Preserve completed tasks ("[x]")
- Do NOT reorder completed tasks
- Group tasks by feature/spec where possible
- Keep tasks small and atomic

---

## Verification Backpressure Rule

- Plan tasks MUST NOT contain "Verify: TBD".
- If a spec scenario has "Verification: TBD", create an explicit task whose
  outcome is to define and implement verification.

---

## Definition of Done (Planner)

Your task is complete when:
- "{{.PlanPath}}" exists
- Every task traces to an approved spec
- Every task has a verification command
- No code has been written

STOP once the plan is updated.
`

const promptBuild = `# ROLE: Builder (Plan Execution)

You are acting as a Builder.

Your responsibility is to execute the implementation plan
ONE TASK AT A TIME with strict verification backpressure.

You MUST NOT:
- Skip verification
- Work on multiple tasks in one iteration
- Modify specs or plan structure (except ticking a task)
- Implement functionality without first searching for existing implementations
- Create parallel or duplicate logic
- Run multiple build/test strategies in parallel

You MUST:
- Complete exactly ONE unchecked plan task per iteration
- Run verification commands
- Commit verified changes

---

## Build Context (auto-generated)

Plan: {{.PlanPath}}

{{.PlanSummary}}

---

## Phase 0a — Orientation

1. Study "AGENTS.md" and follow its commands exactly.
2. Study "{{.PlanPath}}".

---

## Phase 0b — Task Selection

1. Identify the FIRST unchecked task "[ ]".
2. Read the referenced spec section carefully.
3. Understand the required outcome and verification command.
4. If the task has no "Verify:" command or it is clearly invalid, STOP and ask for a plan fix.

---

## Phase 0c — Codebase Reconnaissance (MANDATORY)

Before writing or modifying code:

1. Search the codebase for existing implementations related to this task.
2. Identify relevant files, functions, tests, or utilities.
3. Do NOT assume the functionality does not exist.

---

## Phase 1 — Implementation

1. Make the MINIMAL code changes required to satisfy the task.
2. Follow existing repo conventions.
3. Do NOT refactor unrelated code.

---

## Phase 2 — Verification (MANDATORY)

1. Run the task’s "Verify:" command(s).
2. If verification FAILS:
   - Fix the issue
   - Re-run verification
   - Repeat until it PASSES
3. Do NOT move on until verification passes.

Use exactly one verification approach per task, as defined in the plan.

---

## Phase 3 — Commit &amp; Update Plan

1. Mark the task as complete "[x]" in "{{.PlanPath}}".
2. Commit changes with a message referencing the task ID:
   e.g. "T3: enforce unique user email"
3. Push if this repo expects pushes (see "AGENTS.md").

---

## Definition of Done (Builder)

Your iteration is complete when:
- Verification passes
- One task is checked
- One commit is created

STOP after completing ONE task.
`

const specTemplate = `---
id: &lt;slug&gt;
status: draft # draft | approved
version: 0.1.0
owner: &lt;optional&gt;
---

# &lt;Feature/Topic Name&gt;

## 1. Context &amp; User Story
As a &lt;role&gt;, I want &lt;action&gt;, so that &lt;benefit&gt;.

## 2. Non-Goals
- ...

## 3. Contract (SpecFirst)
Contract format: &lt;TypeScript | JSON Schema | OpenAPI | SQL | UI State | CLI | Other&gt;

&lt;contract content here&gt;

## 4. Completion Contract
Success condition:
- &lt;state or output that must be true&gt;

Verification commands:
- &lt;exact command(s) to prove completion&gt;

Artifacts/flags:
- &lt;files, markers, or outputs that must exist&gt;

## 5. Scenarios (Acceptance Criteria)
### Scenario: &lt;name&gt;
Given ...
When ...
Then ...

Verification:
- &lt;exact command(s) to prove this scenario&gt; (or "TBD: add harness")

## 6. Constraints / NFRs
- Performance:
- Security:
- Compatibility:
- Observability:

## 7. Open Questions / Assumptions
- Assumption:
- Open question:
`

const specReadme = `# Specs

This folder contains one spec per topic of concern.

## Template

All specs must follow "specs/_TEMPLATE.md" and include frontmatter.
Completion contracts and verification commands are mandatory to define "done."

## Approval Gate

- Approval is a human decision recorded in spec frontmatter.
- Planning may be automated, but approval is not.
- Approval is recorded when the human reviewer explicitly instructs the agent to mark the spec as approved.
- Changing an approved spec requires explicit human instruction to flip "status" back to "draft" or to update "status: approved".
`

const agentsTemplate = `# AGENTS

## Repo Layout
- specs/: specifications
- src/: application code
- IMPLEMENTATION_PLAN.md: task list

## Commands
- Tests (fast): [test command]
- Tests (full): [full test command]
- Lint: [lint command]
- Typecheck/build: [typecheck/build command]

## Git
- Status: git status
- Diff: git diff
- Log: git log -5 --oneline

## Definition of Done
- Verify command passes
- Plan task checked
- Commit created
`

const planTemplate = `# Implementation Plan

&lt;!-- Task lines must use "- [ ]" or "- [x]" for rauf to detect status. --&gt;

## Feature: &lt;name&gt; (from specs/&lt;slug&gt;.md)
- [ ] T1: &lt;task title&gt;
  - Spec: specs/&lt;slug&gt;.md#&lt;section&gt;
  - Verify: &lt;command&gt;
  - Outcome: &lt;what success looks like&gt;
  - Notes: &lt;optional&gt;
`

const configTemplate = `# rauf configuration
# Environment variables override this file.

harness: claude
harness_args: ""
no_push: false
log_dir: logs
runtime: host # host | docker | docker-persist
docker_image: ""
docker_args: ""
docker_container: ""
max_files_changed: 0
max_commits_per_iteration: 0
forbidden_paths: ""
no_progress_iterations: 2
on_verify_fail: soft_reset # soft_reset | keep_commit | hard_reset | no_push_only | wip_branch
verify_missing_policy: strict # strict | agent_enforced | fallback
allow_verify_fallback: false
require_verify_on_change: false
require_verify_for_plan_update: false
retry_on_failure: false
retry_max_attempts: 3
retry_backoff_base: 2s
retry_backoff_max: 30s
retry_jitter: true
retry_match: "rate limit,429,overloaded,timeout"
strategy:
  - mode: plan
    iterations: 1
  - mode: build
    iterations: 5
    until: verify_pass
`
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "bufio"
        "os"
        "regexp"
        "strings"
)

type planTask struct {
        TitleLine         string
        VerifyCmds        []string
        VerifyPlaceholder bool
        SpecRefs          []string
        TaskBlock         []string
        FilesMentioned    []string
}

type planLintResult struct {
        MultipleVerify  bool
        MultipleOutcome bool
}

func readActiveTask(planPath string) (planTask, bool, error) <span class="cov8" title="1">{
        file, err := os.Open(planPath)
        if err != nil </span><span class="cov0" title="0">{
                return planTask{}, false, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        taskLine := regexp.MustCompile(`^\s*[-*]\s+\[\s\]\s+(.+)$`)
        verifyLine := regexp.MustCompile(`^\s*[-*]\s+Verify:\s*(.*)$`)
        specLine := regexp.MustCompile(`^\s*[-*]\s+Spec:\s*(.+)$`)

        var task planTask
        found := false
        collecting := false
        inVerifyBlock := false

        skipFirstCodeBlock := false
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                // Skip task line matching while inside a code block to avoid
                // incorrectly matching task-like content in code examples
                if !inVerifyBlock </span><span class="cov8" title="1">{
                        if match := taskLine.FindStringSubmatch(line); match != nil </span><span class="cov8" title="1">{
                                if found </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">found = true
                                collecting = true
                                task.TitleLine = strings.TrimSpace(match[1])
                                task.TaskBlock = append(task.TaskBlock, line)
                                continue</span>
                        }
                }
                <span class="cov8" title="1">if !collecting </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">task.TaskBlock = append(task.TaskBlock, line)
                if inVerifyBlock </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(line)
                        if strings.HasPrefix(trimmed, "```") </span><span class="cov8" title="1">{
                                if skipFirstCodeBlock </span><span class="cov8" title="1">{
                                        skipFirstCodeBlock = false
                                        continue</span>
                                }
                                <span class="cov8" title="1">inVerifyBlock = false
                                continue</span>
                        }
                        <span class="cov8" title="1">cmd := strings.TrimSpace(strings.Trim(trimmed, "`"))
                        if cmd == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if isVerifyPlaceholder(cmd) </span><span class="cov0" title="0">{
                                task.VerifyPlaceholder = true
                                continue</span>
                        }
                        <span class="cov8" title="1">task.VerifyCmds = append(task.VerifyCmds, cmd)
                        continue</span>
                }
                <span class="cov8" title="1">if match := verifyLine.FindStringSubmatch(line); match != nil </span><span class="cov8" title="1">{
                        raw := strings.TrimSpace(match[1])
                        // Check for code block BEFORE stripping backticks
                        if raw == "" || strings.HasPrefix(raw, "```") </span><span class="cov8" title="1">{
                                inVerifyBlock = true
                                if raw == "" </span><span class="cov8" title="1">{
                                        skipFirstCodeBlock = true
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }

                        // Now strip inline backticks for single-line verify commands
                        <span class="cov8" title="1">raw = strings.Trim(raw, "`")
                        if raw == "" </span><span class="cov0" title="0">{
                                inVerifyBlock = true
                                continue</span>
                        }
                        <span class="cov8" title="1">if isVerifyPlaceholder(raw) </span><span class="cov0" title="0">{
                                task.VerifyPlaceholder = true
                                continue</span>
                        }
                        <span class="cov8" title="1">task.VerifyCmds = append(task.VerifyCmds, raw)</span>
                }
                <span class="cov8" title="1">if match := specLine.FindStringSubmatch(line); match != nil </span><span class="cov8" title="1">{
                        ref := strings.TrimSpace(match[1])
                        if ref != "" </span><span class="cov8" title="1">{
                                if path, ok := splitSpecPath(ref); ok </span><span class="cov8" title="1">{
                                        task.SpecRefs = append(task.SpecRefs, path)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return planTask{}, false, err
        }</span>
        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                return planTask{}, false, nil
        }</span>

        <span class="cov8" title="1">task.FilesMentioned = extractFileMentions(task.TaskBlock)
        return task, true, nil</span>
}

func lintPlanTask(task planTask) planLintResult <span class="cov8" title="1">{
        return planLintResult{
                MultipleVerify:  len(task.VerifyCmds) &gt; 1,
                MultipleOutcome: countOutcomeLines(task.TaskBlock) &gt; 1,
        }
}</span>

func countOutcomeLines(lines []string) int <span class="cov8" title="1">{
        outcomeLine := regexp.MustCompile(`^\s*[-*]?\s*Outcome:\s*\S+`)
        count := 0
        for _, line := range lines </span><span class="cov8" title="1">{
                if outcomeLine.MatchString(line) </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}

func isVerifyPlaceholder(value string) bool <span class="cov8" title="1">{
        value = strings.ToLower(strings.TrimSpace(value))
        if !strings.HasPrefix(value, "tbd") </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(value) == 3 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">switch value[3] </span>{
        case ' ', ':', '-':<span class="cov8" title="1">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

func splitSpecPath(value string) (string, bool) <span class="cov8" title="1">{
        parts := strings.SplitN(value, "#", 2)
        path := strings.TrimSpace(parts[0])
        if path == "" </span><span class="cov8" title="1">{
                return "", false
        }</span>
        <span class="cov8" title="1">return path, true</span>
}

func extractFileMentions(lines []string) []string <span class="cov8" title="1">{
        seen := make(map[string]struct{})
        paths := []string{}
        candidate := regexp.MustCompile(`[A-Za-z0-9_./-]+\.[A-Za-z0-9]+`)
        for _, line := range lines </span><span class="cov8" title="1">{
                for _, match := range candidate.FindAllString(line, -1) </span><span class="cov0" title="0">{
                        path := strings.Trim(match, "`"+"\""+"'")
                        if path == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if _, ok := seen[path]; ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">absPath, ok := resolveRepoPath(path)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if _, err := os.Stat(absPath); err == nil </span><span class="cov0" title="0">{
                                seen[path] = struct{}{}
                                paths = append(paths, repoRelativePath(absPath))
                        }</span>
                }
        }
        <span class="cov8" title="1">return paths</span>
}

func readAgentsVerifyFallback(path string) []string <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">text := string(data)
        lines := strings.Split(text, "\n")
        candidates := []string{
                "Tests (fast):",
                "Tests (full):",
                "Typecheck/build:",
        }
        for _, prefix := range candidates </span><span class="cov8" title="1">{
                for _, line := range lines </span><span class="cov8" title="1">{
                        line = strings.TrimSpace(line)
                        if !strings.HasPrefix(line, prefix) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">cmd := strings.TrimSpace(strings.TrimPrefix(line, prefix))
                        if cmd == "" || strings.Contains(cmd, "[") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">return []string{cmd}</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

func runPlanWork(name string) error <span class="cov0" title="0">{
        if strings.TrimSpace(name) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("plan-work requires a name")
        }</span>
        <span class="cov0" title="0">originalBranch, err := gitOutput("branch", "--show-current")
        if err != nil || originalBranch == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("git is required for plan-work")
        }</span>

        <span class="cov0" title="0">slug := slugify(name)
        if slug == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to derive branch name")
        }</span>

        <span class="cov0" title="0">newBranch := fmt.Sprintf("rauf/%s", slug)
        branchSwitched := false
        if originalBranch != newBranch </span><span class="cov0" title="0">{
                exists, err := gitBranchExists(newBranch)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                        if err := gitCheckout(newBranch); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := gitCheckoutCreate(newBranch); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">branchSwitched = true</span>
        }

        // Helper to rollback branch switch on failure
        <span class="cov0" title="0">rollback := func() </span><span class="cov0" title="0">{
                if branchSwitched </span><span class="cov0" title="0">{
                        _ = gitCheckout(originalBranch)
                }</span>
        }

        <span class="cov0" title="0">planDir := ".rauf"
        planPath := filepath.Join(planDir, "IMPLEMENTATION_PLAN.md")
        if err := os.MkdirAll(planDir, 0o755); err != nil </span><span class="cov0" title="0">{
                rollback()
                return err
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(planPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.WriteFile(planPath, []byte(planTemplate), 0o644); err != nil </span><span class="cov0" title="0">{
                        rollback()
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := gitConfigSet(fmt.Sprintf("branch.%s.raufScoped", newBranch), "true"); err != nil </span><span class="cov0" title="0">{
                rollback()
                return fmt.Errorf("failed to set branch config: %w", err)
        }</span>
        <span class="cov0" title="0">if err := gitConfigSet(fmt.Sprintf("branch.%s.raufPlanPath", newBranch), planPath); err != nil </span><span class="cov0" title="0">{
                // Clean up the first config setting before rollback
                if unsetErr := gitConfigUnset(fmt.Sprintf("branch.%s.raufScoped", newBranch)); unsetErr != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to clean up git config: %v\n", unsetErr)
                }</span>
                <span class="cov0" title="0">rollback()
                return fmt.Errorf("failed to set branch config: %w", err)</span>
        }

        <span class="cov0" title="0">fmt.Printf("Switched to %s and prepared %s\n", newBranch, planPath)
        return nil</span>
}

func gitBranchExists(name string) (bool, error) <span class="cov0" title="0">{
        _, err := gitOutput("show-ref", "--verify", "--quiet", "refs/heads/"+name)
        if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        // show-ref exits with code 1 when ref doesn't exist, which is expected
        // For other errors (corrupted repo, permission issues), we should propagate
        <span class="cov0" title="0">if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                if exitErr.ExitCode() == 1 </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
        <span class="cov0" title="0">return false, err</span>
}

func gitCheckout(branch string) error <span class="cov0" title="0">{
        _, err := gitOutput("checkout", branch)
        return err
}</span>

func gitCheckoutCreate(branch string) error <span class="cov0" title="0">{
        _, err := gitOutput("checkout", "-b", branch)
        return err
}</span>

func gitConfigSet(key, value string) error <span class="cov0" title="0">{
        _, err := gitOutput("config", key, value)
        return err
}</span>

func gitConfigUnset(key string) error <span class="cov0" title="0">{
        _, err := gitOutput("config", "--unset", key)
        return err
}</span>

func resolvePlanPath(branch string, gitAvailable bool, fallback string) string <span class="cov0" title="0">{
        if !gitAvailable || branch == "" </span><span class="cov0" title="0">{
                return fallback
        }</span>
        <span class="cov0" title="0">path, err := gitOutput("config", "--get", fmt.Sprintf("branch.%s.raufPlanPath", branch))
        if err != nil </span><span class="cov0" title="0">{
                // git config --get exits with code 1 when key doesn't exist (expected)
                // For other errors (corrupted config, permission issues), warn user
                if exitErr, ok := err.(*exec.ExitError); ok &amp;&amp; exitErr.ExitCode() != 1 </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to read branch config for %s: %v\n", branch, err)
                }</span>
                <span class="cov0" title="0">return fallback</span>
        }
        <span class="cov0" title="0">if path != "" </span><span class="cov0" title="0">{
                return path
        }</span>
        <span class="cov0" title="0">return fallback</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
        "bytes"
        "context"
        "crypto/sha256"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"
        "text/template"
        "time"
        "unicode/utf8"
)

type promptData struct {
        Mode                    string
        PlanPath                string
        ActiveTask              string
        VerifyCommand           string
        CapabilityMap           string
        ContextFile             string
        SpecContext             string
        RelevantFiles           string
        RepoMap                 string
        SpecIndex               string
        PlanSummary             string
        PriorVerification       string
        PriorVerificationCmd    string
        PriorVerificationStatus string
}

const (
        maxSpecBytes       = 40 * 1024
        maxRelevantBytes   = 60 * 1024
        maxFileBytes       = 12 * 1024
        maxRepoMapLines    = 200
        maxVerifyOutput    = 12 * 1024
        maxCapabilityBytes = 4 * 1024
        maxContextBytes    = 8 * 1024
)

func buildPromptContent(promptFile string, data promptData) (string, string, error) <span class="cov8" title="1">{
        content, err := os.ReadFile(promptFile)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        // Escape template delimiters in user-controlled fields to prevent injection
        <span class="cov8" title="1">data.ActiveTask = escapeTemplateDelimiters(data.ActiveTask)
        data.VerifyCommand = escapeTemplateDelimiters(data.VerifyCommand)
        data.PlanSummary = escapeTemplateDelimiters(data.PlanSummary)
        data.PriorVerification = escapeTemplateDelimiters(data.PriorVerification)
        data.PriorVerificationCmd = escapeTemplateDelimiters(data.PriorVerificationCmd)

        tmpl, err := template.New(filepath.Base(promptFile)).Option("missingkey=zero").Parse(string(content))
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        if err := tmpl.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">rendered := buf.String()
        hash := sha256.Sum256([]byte(rendered))
        return rendered, fmt.Sprintf("%x", hash), nil</span>
}

// escapeTemplateDelimiters escapes Go template delimiters to prevent template injection
// from user-controlled content like task names or verification output.
func escapeTemplateDelimiters(s string) string <span class="cov8" title="1">{
        // Replace {{ with a literal representation that won't be interpreted as template
        s = strings.ReplaceAll(s, "{{", "{ {")
        s = strings.ReplaceAll(s, "}}", "} }")
        return s
}</span>

func buildContextPack(planPath string, task planTask, verifyCmds []string, state raufState, gitAvailable bool, verifyInstruction string) string <span class="cov8" title="1">{
        var b strings.Builder
        b.WriteString("## Context Pack (auto-generated)\n\n")
        if planPath != "" </span><span class="cov8" title="1">{
                b.WriteString("Plan Path: ")
                b.WriteString(planPath)
                b.WriteString("\n")
        }</span>
        <span class="cov8" title="1">if task.TitleLine != "" </span><span class="cov8" title="1">{
                b.WriteString("Active Task: ")
                b.WriteString(task.TitleLine)
                b.WriteString("\n")
        }</span>
        <span class="cov8" title="1">if len(verifyCmds) == 1 </span><span class="cov8" title="1">{
                b.WriteString("Verify: ")
                b.WriteString(verifyCmds[0])
                b.WriteString("\n")
        }</span> else<span class="cov8" title="1"> if len(verifyCmds) &gt; 1 </span><span class="cov8" title="1">{
                b.WriteString("Verify:\n")
                for _, cmd := range verifyCmds </span><span class="cov8" title="1">{
                        cmd = strings.TrimSpace(cmd)
                        if cmd == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">b.WriteString("- ")
                        b.WriteString(cmd)
                        b.WriteString("\n")</span>
                }
        }
        <span class="cov8" title="1">b.WriteString("\n")

        if verifyInstruction != "" </span><span class="cov8" title="1">{
                b.WriteString("SYSTEM: ")
                b.WriteString(verifyInstruction)
                b.WriteString("\n\n")
        }</span>

        <span class="cov8" title="1">if state.LastVerificationOutput != "" </span><span class="cov8" title="1">{
                b.WriteString("SYSTEM: Previous verification failed.\n")
                if state.LastVerificationCommand != "" </span><span class="cov8" title="1">{
                        b.WriteString("Command: ")
                        b.WriteString(state.LastVerificationCommand)
                        b.WriteString("\n")
                }</span>
                <span class="cov8" title="1">b.WriteString("Output (truncated):\n\n```")
                b.WriteString(state.LastVerificationOutput)
                b.WriteString("\n```\n\n")</span>
        }

        <span class="cov8" title="1">specs := readSpecContexts(task.SpecRefs, maxSpecBytes)
        if specs != "" </span><span class="cov0" title="0">{
                b.WriteString("### Spec Context\n\n")
                b.WriteString(specs)
                b.WriteString("\n")
        }</span>

        <span class="cov8" title="1">files := readRelevantFiles(task, gitAvailable, maxRelevantBytes)
        if files != "" </span><span class="cov0" title="0">{
                b.WriteString("### Relevant Files\n\n")
                b.WriteString(files)
                b.WriteString("\n")
        }</span>

        <span class="cov8" title="1">return b.String()</span>
}

func readSpecContexts(paths []string, maxBytes int) string <span class="cov8" title="1">{
        seen := make(map[string]struct{})
        var b strings.Builder
        budget := maxBytes
        // Cache the root directory for consistent path resolution
        root, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, path := range paths </span><span class="cov0" title="0">{
                path = filepath.Clean(path)
                if _, ok := seen[path]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">absPath, ok := resolveRepoPathWithRoot(path, root)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">data, err := os.ReadFile(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[path] = struct{}{}
                chunk := string(data)
                chunk = truncateHead(chunk, minInt(maxBytes, budget))
                if chunk == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">b.WriteString("#### ")
                b.WriteString(repoRelativePathWithRoot(absPath, root))
                b.WriteString("\n\n```")
                b.WriteString(chunk)
                b.WriteString("\n```\n\n")
                budget -= len(chunk)
                if budget &lt;= 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return strings.TrimSpace(b.String())</span>
}

func readRelevantFiles(task planTask, gitAvailable bool, maxBytes int) string <span class="cov8" title="1">{
        paths := append([]string{}, task.FilesMentioned...)
        if gitAvailable </span><span class="cov0" title="0">{
                paths = append(paths, searchRelevantFiles(task)...)
        }</span>
        <span class="cov8" title="1">seen := make(map[string]struct{})
        var b strings.Builder
        budget := maxBytes
        // Cache the root directory for consistent path resolution
        root, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">for _, path := range paths </span><span class="cov0" title="0">{
                path = filepath.Clean(path)
                if _, ok := seen[path]; ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">absPath, ok := resolveRepoPathWithRoot(path, root)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">data, err := os.ReadFile(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">seen[path] = struct{}{}
                chunk := truncateHead(string(data), minInt(maxFileBytes, budget))
                if chunk == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">b.WriteString("#### ")
                b.WriteString(repoRelativePathWithRoot(absPath, root))
                b.WriteString("\n\n```")
                b.WriteString(chunk)
                b.WriteString("\n```\n\n")
                budget -= len(chunk)
                if budget &lt;= 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return strings.TrimSpace(b.String())</span>
}

func readAgentsCapabilityMap(path string, maxBytes int) string <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">lines := strings.Split(string(data), "\n")
        section := ""
        var b strings.Builder
        for _, line := range lines </span><span class="cov8" title="1">{
                trimmed := strings.TrimSpace(line)
                if strings.HasPrefix(trimmed, "## ") </span><span class="cov8" title="1">{
                        section = strings.TrimSpace(strings.TrimPrefix(trimmed, "## "))
                        continue</span>
                }
                <span class="cov8" title="1">if section != "Commands" &amp;&amp; section != "Git" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(trimmed, "- ") </span><span class="cov8" title="1">{
                        if b.Len() &gt; 0 </span><span class="cov8" title="1">{
                                b.WriteString("\n")
                        }</span>
                        <span class="cov8" title="1">b.WriteString(trimmed)</span>
                }
        }
        <span class="cov8" title="1">return truncateHead(strings.TrimSpace(b.String()), maxBytes)</span>
}

func readContextFile(path string, maxBytes int) string <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return truncateHead(strings.TrimSpace(string(data)), maxBytes)</span>
}

func searchRelevantFiles(task planTask) []string <span class="cov0" title="0">{
        if _, err := exec.LookPath("rg"); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">terms := extractSearchTerms(task)
        if len(terms) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">seen := make(map[string]struct{})
        results := []string{}
        for _, term := range terms </span><span class="cov0" title="0">{
                if len(results) &gt;= 8 </span><span class="cov0" title="0">{
                        break</span>
                }
                // Use a timeout to prevent hanging on large repos or pathological inputs
                <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                args := []string{"-l", "-F", "-i", "--max-count", "1", term}
                cmd := exec.CommandContext(ctx, "rg", args...)
                output, err := cmd.Output()
                cancel()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, line := range strings.Split(string(output), "\n") </span><span class="cov0" title="0">{
                        line = strings.TrimSpace(line)
                        if line == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if _, ok := seen[line]; ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">seen[line] = struct{}{}
                        results = append(results, line)
                        if len(results) &gt;= 8 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        <span class="cov0" title="0">return results</span>
}

func extractSearchTerms(task planTask) []string <span class="cov8" title="1">{
        stop := map[string]struct{}{
                "this": {}, "that": {}, "with": {}, "from": {}, "will": {}, "should": {}, "would": {}, "could": {},
                "when": {}, "then": {}, "them": {}, "they": {}, "into": {}, "your": {}, "task": {}, "plan": {},
                "verify": {}, "spec": {}, "notes": {}, "outcome": {}, "build": {}, "mode": {},
        }
        wordPattern := regexp.MustCompile(`[A-Za-z][A-Za-z0-9_-]{3,}`)
        lines := append([]string{task.TitleLine}, task.TaskBlock...)
        seen := make(map[string]struct{})
        terms := []string{}
        for _, line := range lines </span><span class="cov8" title="1">{
                lower := strings.ToLower(line)
                if strings.Contains(lower, "verify:") || strings.Contains(lower, "spec:") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, match := range wordPattern.FindAllString(line, -1) </span><span class="cov8" title="1">{
                        word := strings.ToLower(match)
                        if _, ok := stop[word]; ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if _, ok := seen[word]; ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[word] = struct{}{}
                        terms = append(terms, word)
                        if len(terms) &gt;= 6 </span><span class="cov8" title="1">{
                                return terms
                        }</span>
                }
        }
        <span class="cov8" title="1">return terms</span>
}

func truncateHead(value string, max int) string <span class="cov8" title="1">{
        if max &lt;= 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(value) &lt;= max </span><span class="cov8" title="1">{
                return value
        }</span>
        // Truncate by bytes, then back up to valid UTF-8 boundary
        <span class="cov8" title="1">truncated := value[:max]
        for len(truncated) &gt; 0 &amp;&amp; !utf8.ValidString(truncated) </span><span class="cov0" title="0">{
                truncated = truncated[:len(truncated)-1]
        }</span>
        <span class="cov8" title="1">return truncated</span>
}

func truncateTail(value string, max int) string <span class="cov8" title="1">{
        if max &lt;= 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(value) &lt;= max </span><span class="cov8" title="1">{
                return value
        }</span>
        // Truncate by bytes from end, then advance to valid UTF-8 boundary
        <span class="cov8" title="1">start := len(value) - max
        for start &lt; len(value) &amp;&amp; !utf8.RuneStart(value[start]) </span><span class="cov0" title="0">{
                start++
        }</span>
        <span class="cov8" title="1">return value[start:]</span>
}

func minInt(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func buildRepoMap(gitAvailable bool) string <span class="cov8" title="1">{
        if !gitAvailable </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">files, err := gitOutput("ls-files")
        if err != nil || files == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">lines := strings.Split(files, "\n")
        if len(lines) &gt; maxRepoMapLines </span><span class="cov0" title="0">{
                lines = lines[:maxRepoMapLines]
        }</span>
        <span class="cov0" title="0">return strings.Join(lines, "\n")</span>
}

func buildSpecIndex() string <span class="cov8" title="1">{
        entries, err := listSpecs()
        if err != nil || len(entries) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">var b strings.Builder
        for _, entry := range entries </span><span class="cov0" title="0">{
                b.WriteString(entry)
                b.WriteString("\n")
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(b.String())</span>
}

func readRecentFiles() []string <span class="cov0" title="0">{
        status, err := gitOutputRaw("status", "--porcelain")
        if err != nil || status == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">lines := strings.Split(status, "\n")
        paths := []string{}
        for _, line := range lines </span><span class="cov0" title="0">{
                // Git porcelain v1 format: "XY PATH" where XY are 2 status chars followed by space
                // Minimum valid: 2 status + 1 space + 1 char path = 4 chars
                line = strings.TrimRight(line, "\r")
                if len(line) &lt; 4 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">path := parseStatusPath(line[3:])
                if path == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">paths = append(paths, path)</span>
        }
        <span class="cov0" title="0">return paths</span>
}

func buildPlanSummary(planPath string, task planTask) string <span class="cov8" title="1">{
        if task.TitleLine == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">var b strings.Builder
        b.WriteString("Active task from ")
        b.WriteString(planPath)
        b.WriteString(":\n")
        for _, line := range task.TaskBlock </span><span class="cov8" title="1">{
                b.WriteString(line)
                b.WriteString("\n")
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(b.String())</span>
}

func normalizeVerifyOutput(output string) string <span class="cov8" title="1">{
        output = strings.TrimSpace(output)
        if output == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return truncateTail(output, maxVerifyOutput)</span>
}

func resolveRepoPath(path string) (string, bool) <span class="cov8" title="1">{
        return resolveRepoPathWithRoot(path, "")
}</span>

func resolveRepoPathWithRoot(path string, root string) (string, bool) <span class="cov8" title="1">{
        if root == "" </span><span class="cov8" title="1">{
                var err error
                root, err = os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", false
                }</span>
        }
        <span class="cov8" title="1">clean := filepath.Clean(path)
        if filepath.IsAbs(clean) </span><span class="cov0" title="0">{
                if !isWithinRoot(root, clean) </span><span class="cov0" title="0">{
                        return "", false
                }</span>
                <span class="cov0" title="0">return clean, true</span>
        }
        <span class="cov8" title="1">abs := filepath.Join(root, clean)
        if !isWithinRoot(root, abs) </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov8" title="1">return abs, true</span>
}

func repoRelativePath(absPath string) string <span class="cov8" title="1">{
        return repoRelativePathWithRoot(absPath, "")
}</span>

func repoRelativePathWithRoot(absPath string, root string) string <span class="cov8" title="1">{
        if root == "" </span><span class="cov8" title="1">{
                var err error
                root, err = os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return absPath
                }</span>
        }
        <span class="cov8" title="1">rel, err := filepath.Rel(root, absPath)
        if err != nil </span><span class="cov0" title="0">{
                return absPath
        }</span>
        <span class="cov8" title="1">return filepath.Clean(rel)</span>
}

func isWithinRoot(root, target string) bool <span class="cov8" title="1">{
        // Resolve symlinks in root to get canonical path
        resolvedRoot, err := filepath.EvalSymlinks(root)
        if err != nil </span><span class="cov0" title="0">{
                // If root can't be resolved, use the original
                resolvedRoot = root
        }</span>

        // Resolve symlinks in target to detect path traversal via symlinks
        <span class="cov8" title="1">resolvedTarget, err := filepath.EvalSymlinks(target)
        if err != nil </span><span class="cov8" title="1">{
                // If target doesn't exist or can't be resolved, check the unresolved path
                // This is safe because the file read will fail anyway if it doesn't exist
                resolvedTarget = target
        }</span>

        <span class="cov8" title="1">rel, err := filepath.Rel(resolvedRoot, resolvedTarget)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">rel = filepath.Clean(rel)
        if rel == "." </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if rel == ".." || strings.HasPrefix(rel, ".."+string(filepath.Separator)) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "os"
        "os/signal"
        "strings"
        "time"
)

type iterationResult struct {
        VerifyStatus string
        VerifyOutput string
        Stalled      bool
        HeadBefore   string
        HeadAfter    string
        NoProgress   int
        ExitReason   string
}

const completionSentinel = "RAUF_COMPLETE"

func runStrategy(cfg modeConfig, fileCfg runtimeConfig, runner runtimeExec, state raufState, gitAvailable bool, branch, planPath string, harness, harnessArgs string, noPush bool, logDir string, retryEnabled bool, retryMaxAttempts int, retryBackoffBase, retryBackoffMax time.Duration, retryJitter bool, retryMatch []string) <span class="cov8" title="1">{
        lastResult := iterationResult{}
        for _, step := range fileCfg.Strategy </span><span class="cov8" title="1">{
                if !shouldRunStep(step, lastResult) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">modeCfg := cfg
                modeCfg.mode = step.Mode
                modeCfg.promptFile = promptForMode(step.Mode)
                maxIterations := step.Iterations
                if maxIterations &lt;= 0 </span><span class="cov0" title="0">{
                        maxIterations = 1
                }</span>
                <span class="cov8" title="1">modeCfg.maxIterations = 1
                // Reset NoProgress counter at the start of each strategy step
                stepNoProgress := 0
                for i := 0; i &lt; maxIterations; i++ </span><span class="cov8" title="1">{
                        result := runMode(modeCfg, fileCfg, runner, state, gitAvailable, branch, planPath, harness, harnessArgs, noPush, logDir, retryEnabled, retryMaxAttempts, retryBackoffBase, retryBackoffMax, retryJitter, retryMatch, stepNoProgress)
                        lastResult = result
                        stepNoProgress = result.NoProgress
                        if result.ExitReason == "no_progress" </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">if !shouldContinueUntil(step, result) </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
}

func runMode(cfg modeConfig, fileCfg runtimeConfig, runner runtimeExec, state raufState, gitAvailable bool, branch, planPath string, harness, harnessArgs string, noPush bool, logDir string, retryEnabled bool, retryMaxAttempts int, retryBackoffBase, retryBackoffMax time.Duration, retryJitter bool, retryMatch []string, startNoProgress int) iterationResult <span class="cov8" title="1">{
        iteration := 0
        noProgress := startNoProgress
        maxNoProgress := fileCfg.NoProgressIters
        if maxNoProgress &lt;= 0 </span><span class="cov0" title="0">{
                maxNoProgress = 2
        }</span>
        <span class="cov8" title="1">logDirName := strings.TrimSpace(logDir)
        if logDirName == "" </span><span class="cov0" title="0">{
                logDirName = "logs"
        }</span>
        <span class="cov8" title="1">excludeDirs := []string{".git", ".rauf", logDirName}

        lastResult := iterationResult{}

        for </span><span class="cov8" title="1">{
                if cfg.maxIterations &gt; 0 &amp;&amp; iteration &gt;= cfg.maxIterations </span><span class="cov8" title="1">{
                        fmt.Printf("Reached max iterations: %d\n", cfg.maxIterations)
                        break</span>
                }
                <span class="cov8" title="1">iterNum := iteration + 1

                if cfg.mode == "plan" || cfg.mode == "build" </span><span class="cov8" title="1">{
                        if err := lintSpecs(); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, err)
                                os.Exit(1)
                        }</span>
                }

                // Note: We don't check for unchecked tasks here at the start of iteration
                // because state.LastVerificationStatus may be stale. The check is done
                // after verification runs, using the current iteration's verifyStatus.

                <span class="cov8" title="1">headBefore := ""
                if gitAvailable </span><span class="cov0" title="0">{
                        var err error
                        headBefore, err = gitOutput("rev-parse", "HEAD")
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, "Error: unable to read git HEAD")
                                os.Exit(1)
                        }</span>
                }

                <span class="cov8" title="1">planHashBefore := ""
                if hasPlanFile(planPath) </span><span class="cov0" title="0">{
                        planHashBefore = fileHash(planPath)
                }</span>

                <span class="cov8" title="1">var task planTask
                var verifyCmds []string
                verifyPolicy := ""
                needVerifyInstruction := ""
                missingVerify := false
                lintPolicy := ""
                if cfg.mode == "build" </span><span class="cov0" title="0">{
                        if active, ok, err := readActiveTask(planPath); err == nil &amp;&amp; ok </span><span class="cov0" title="0">{
                                task = active
                                verifyCmds = append([]string{}, active.VerifyCmds...)
                                lintPolicy = normalizePlanLintPolicy(fileCfg)
                                if lintPolicy != "off" </span><span class="cov0" title="0">{
                                        issues := lintPlanTask(task)
                                        if issues.MultipleVerify || issues.MultipleOutcome </span><span class="cov0" title="0">{
                                                var warnings []string
                                                if issues.MultipleVerify </span><span class="cov0" title="0">{
                                                        warnings = append(warnings, "multiple Verify commands")
                                                }</span>
                                                <span class="cov0" title="0">if issues.MultipleOutcome </span><span class="cov0" title="0">{
                                                        warnings = append(warnings, "multiple Outcome lines")
                                                }</span>
                                                <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "Plan lint: %s\n", strings.Join(warnings, "; "))
                                                if lintPolicy == "fail" </span><span class="cov0" title="0">{
                                                        os.Exit(1)
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Plan lint: unable to parse active task: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">verifyPolicy = normalizeVerifyMissingPolicy(fileCfg)
                        if len(verifyCmds) == 0 &amp;&amp; (verifyPolicy == "fallback") </span><span class="cov0" title="0">{
                                verifyCmds = readAgentsVerifyFallback("AGENTS.md")
                                if len(verifyCmds) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Println("Using AGENTS.md verify fallback (explicitly enabled).")
                                }</span>
                        }
                        <span class="cov0" title="0">if len(verifyCmds) == 0 </span><span class="cov0" title="0">{
                                if verifyPolicy == "agent_enforced" </span><span class="cov0" title="0">{
                                        missingVerify = true
                                        missingReason := "missing"
                                        if task.VerifyPlaceholder </span><span class="cov0" title="0">{
                                                missingReason = "placeholder (Verify: TBD)"
                                        }</span>
                                        <span class="cov0" title="0">needVerifyInstruction = fmt.Sprintf("This task has no valid Verify command (%s). Your only job is to update the plan with a correct Verify command.", missingReason)</span>
                                } else<span class="cov0" title="0"> {
                                        missingReason := "missing"
                                        if task.VerifyPlaceholder </span><span class="cov0" title="0">{
                                                missingReason = "placeholder (Verify: TBD)"
                                        }</span>
                                        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "Error: verification command %s. Update the plan before continuing.\n", missingReason)
                                        os.Exit(1)</span>
                                }
                        }
                }

                <span class="cov8" title="1">fingerprintBefore := ""
                fingerprintBeforePlanExcluded := ""
                if !gitAvailable </span><span class="cov8" title="1">{
                        fingerprintBefore = workspaceFingerprint(".", excludeDirs, nil)
                        if missingVerify &amp;&amp; planPath != "" </span><span class="cov0" title="0">{
                                fingerprintBeforePlanExcluded = workspaceFingerprint(".", excludeDirs, []string{planPath})
                        }</span>
                }

                <span class="cov8" title="1">backpressurePack := ""
                if cfg.mode == "build" || cfg.mode == "plan" </span><span class="cov8" title="1">{
                        backpressurePack = buildBackpressurePack(state, gitAvailable)
                }</span>
                <span class="cov8" title="1">state.BackpressureInjected = backpressurePack != ""

                contextPack := ""
                if cfg.mode == "build" </span><span class="cov0" title="0">{
                        contextPack = buildContextPack(planPath, task, verifyCmds, state, gitAvailable, needVerifyInstruction)
                }</span>

                <span class="cov8" title="1">repoMap := ""
                specIndex := ""
                planSummary := ""
                if cfg.mode == "architect" </span><span class="cov0" title="0">{
                        repoMap = buildRepoMap(gitAvailable)
                }</span>
                <span class="cov8" title="1">if cfg.mode == "plan" </span><span class="cov8" title="1">{
                        specIndex = buildSpecIndex()
                        repoMap = buildRepoMap(gitAvailable)
                }</span>
                <span class="cov8" title="1">if cfg.mode == "build" </span><span class="cov0" title="0">{
                        planSummary = buildPlanSummary(planPath, task)
                }</span>
                <span class="cov8" title="1">capabilityMap := readAgentsCapabilityMap("AGENTS.md", maxCapabilityBytes)
                contextFile := readContextFile(".rauf/context.md", maxContextBytes)

                promptContent, promptHash, err := buildPromptContent(cfg.promptFile, promptData{
                        Mode:                    cfg.mode,
                        PlanPath:                planPath,
                        ActiveTask:              task.TitleLine,
                        VerifyCommand:           formatVerifyCommands(verifyCmds),
                        CapabilityMap:           capabilityMap,
                        ContextFile:             contextFile,
                        SpecContext:             "",
                        RelevantFiles:           "",
                        RepoMap:                 repoMap,
                        SpecIndex:               specIndex,
                        PlanSummary:             planSummary,
                        PriorVerification:       state.LastVerificationOutput,
                        PriorVerificationCmd:    state.LastVerificationCommand,
                        PriorVerificationStatus: state.LastVerificationStatus,
                })
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }</span>
                <span class="cov8" title="1">if backpressurePack != "" || contextPack != "" </span><span class="cov0" title="0">{
                        promptContent = backpressurePack + contextPack + "\n\n" + promptContent
                }</span>

                <span class="cov8" title="1">logFile, logPath, err := openLogFile(cfg.mode, logDir)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, err)
                        os.Exit(1)
                }</span>
                <span class="cov8" title="1">fmt.Printf("Logs:   %s\n", logPath)

                writeLogEntry(logFile, logEntry{
                        Type:       "iteration_start",
                        Mode:       cfg.mode,
                        Iteration:  iterNum,
                        VerifyCmd:  formatVerifyCommands(verifyCmds),
                        PlanHash:   planHashBefore,
                        PromptHash: promptHash,
                        Branch:     branch,
                })

                ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt)
                retryCfg := retryConfig{
                        Enabled:     retryEnabled,
                        MaxAttempts: retryMaxAttempts,
                        BackoffBase: retryBackoffBase,
                        BackoffMax:  retryBackoffMax,
                        Jitter:      retryJitter,
                        Match:       retryMatch,
                }

                // Compute effective harness args with model escalation
                effectiveHarnessArgs := harnessArgs
                escalated := false
                escalationReason := ""
                if fileCfg.ModelEscalation.Enabled </span><span class="cov0" title="0">{
                        // Check if we should escalate
                        if shouldEscalate, reason := shouldEscalateModel(state, fileCfg); shouldEscalate </span><span class="cov0" title="0">{
                                if state.CurrentModel != fileCfg.ModelStrong </span><span class="cov0" title="0">{
                                        state.CurrentModel = fileCfg.ModelStrong
                                        state.EscalationCount++
                                        state.EscalationCooldownRemaining = fileCfg.ModelEscalation.CooldownIters
                                        state.LastEscalationReason = reason
                                        escalated = true
                                        escalationReason = reason
                                        fmt.Printf("Model escalation triggered: %s -&gt; %s (reason: %s)\n",
                                                fileCfg.ModelDefault, fileCfg.ModelStrong, reason)
                                }</span>
                        }
                        // Apply model to harness args
                        <span class="cov0" title="0">model := computeEffectiveModel(state, fileCfg)
                        if model != "" </span><span class="cov0" title="0">{
                                effectiveHarnessArgs = applyModelChoice(harnessArgs, fileCfg.ModelFlag, model)
                        }</span>
                }

                <span class="cov8" title="1">harnessRes, err := runHarness(ctx, promptContent, harness, effectiveHarnessArgs, logFile, retryCfg, runner)
                if err != nil </span><span class="cov0" title="0">{
                        stop() // Clean up signal handler
                        if closeErr := logFile.Close(); closeErr != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, closeErr)
                        }</span>
                        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, "Interrupted. Exiting.")
                                os.Exit(130)
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintln(os.Stderr, "Harness run failed:", err)
                        os.Exit(1)</span>
                }
                <span class="cov8" title="1">output := harnessRes.Output

                // Check for backpressure response acknowledgment
                backpressureAcknowledged := true
                if state.BackpressureInjected &amp;&amp; !hasBackpressureResponse(output) </span><span class="cov0" title="0">{
                        fmt.Println("Warning: Backpressure was present but model did not include '## Backpressure Response' section.")
                        backpressureAcknowledged = false
                }</span>

                // Persist retry info for backpressure
                <span class="cov8" title="1">state.PriorRetryCount = harnessRes.RetryCount
                state.PriorRetryReason = harnessRes.RetryReason

                // Capture hypothesis if provided (especially important after consecutive failures)
                if cfg.mode == "build" &amp;&amp; state.ConsecutiveVerifyFails &gt;= 2 </span><span class="cov0" title="0">{
                        hyp, diffAction := extractHypothesis(output)
                        if hyp != "" &amp;&amp; diffAction != "" </span><span class="cov0" title="0">{
                                // Record the hypothesis
                                state.Hypotheses = append(state.Hypotheses, Hypothesis{
                                        Timestamp:       time.Now().UTC(),
                                        Iteration:       iterNum,
                                        Hypothesis:      hyp,
                                        DifferentAction: diffAction,
                                        VerifyCommand:   formatVerifyCommands(verifyCmds),
                                })
                                // Keep only last 10 hypotheses to avoid state bloat
                                if len(state.Hypotheses) &gt; 10 </span><span class="cov0" title="0">{
                                        state.Hypotheses = state.Hypotheses[len(state.Hypotheses)-10:]
                                }</span>
                        } else<span class="cov0" title="0"> if !hasRequiredHypothesis(output) </span><span class="cov0" title="0">{
                                fmt.Println("Warning: Hypothesis required after consecutive verify failures but model did not include HYPOTHESIS: and DIFFERENT_THIS_TIME: lines.")
                        }</span>
                }

                <span class="cov8" title="1">completionSignal := ""
                completionOk := true
                completionSpecs := []string{}
                completionArtifacts := []string{}
                if hasCompletionSentinel(output) </span><span class="cov0" title="0">{
                        completionSignal = completionSentinel
                        if cfg.mode == "build" </span><span class="cov0" title="0">{
                                var reason string
                                completionOk, reason, completionSpecs, completionArtifacts = checkCompletionArtifacts(task.SpecRefs)
                                if !completionOk </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "Completion blocked: %s\n", reason)
                                }</span>
                        }
                }

                <span class="cov8" title="1">prevVerifyStatus := state.LastVerificationStatus
                prevVerifyHash := state.LastVerificationHash
                currentVerifyHash := "" // Will be set after verification runs
                if cfg.mode == "architect" </span><span class="cov0" title="0">{
                        // The user's snippet implies a `questionsAsked` variable, which is not defined here.
                        // Assuming the intent is to always run architect questions if in architect mode,
                        // and that `runArchitectQuestions` now returns `updatedOutput` and a boolean `questionsAsked`
                        // or similar, which is then used to decide if `output` should be updated.
                        // The provided snippet is:
                        // if questionsAsked {
                        //         updatedOutput, _ := runArchitectQuestions(ctx, runner, &amp;promptContent, output, state, harness, harnessArgs, logFile, retryCfg, os.Stdin, os.Stdout)
                        //         output = updatedOutput
                        // }
                        // This implies `questionsAsked` is a boolean that determines if the call happens.
                        // The original code was `if updated, ok := runArchitectQuestions(...); ok { output = updated }`.
                        // To faithfully apply the change, I will assume `runArchitectQuestions` now returns `updatedOutput, questionsAsked`
                        // and that `questionsAsked` is the new `ok` equivalent.
                        // However, the user's snippet explicitly uses `if questionsAsked { ... }` and then calls `runArchitectQuestions`
                        // inside it, which is a bit contradictory if `questionsAsked` is a return value.
                        // Given the instruction "Update the call to runArchitectQuestions... to pass os.Stdin and os.Stdout",
                        // and the provided code edit, I will interpret it as:
                        // 1. The `runArchitectQuestions` function now takes `io.Reader` and `io.Writer` as last arguments.
                        // 2. The return signature might have changed, but the user's snippet shows `updatedOutput, _`.
                        // 3. The `if` condition `if questionsAsked` suggests `questionsAsked` is a pre-existing boolean.
                        //
                        // To make the change syntactically correct and faithful to the provided snippet,
                        // I will assume `questionsAsked` is a boolean that needs to be determined *before* the call,
                        // or that the user intends for `runArchitectQuestions` to return `updatedOutput, questionsAsked`
                        // and then `questionsAsked` is used in the `if` condition.
                        //
                        // The most direct interpretation of the provided snippet, while maintaining syntactic correctness,
                        // is to replace the existing `if` block with the new one, assuming `questionsAsked` is a boolean
                        // that is either always true in this context or determined elsewhere.
                        //
                        // Given the original `if updated, ok := runArchitectQuestions(...); ok { output = updated }`,
                        // and the user's desired `if questionsAsked { updatedOutput, _ := runArchitectQuestions(...); output = updatedOutput }`,
                        // it seems the user wants to change the way the return values are handled and add the new arguments.
                        // The `if questionsAsked` part is problematic without context.
                        //
                        // Let's assume the user wants to *replace* the existing call and its surrounding `if` with the new structure.
                        // The most faithful way to apply the *provided code edit* is to literally insert it.
                        // The `if cfg.mode == "arch"` part in the user's snippet is a typo and should be `architect`.
                        // The `if questionsAsked` block implies `questionsAsked` is a boolean.
                        // If `runArchitectQuestions` is now expected to return `(string, bool)` where the bool is `questionsAsked`,
                        // then the structure would be `updatedOutput, questionsAsked := runArchitectQuestions(...)`.
                        //
                        // However, the user's snippet has `if questionsAsked { updatedOutput, _ := runArchitectQuestions(...) }`.
                        // This implies `questionsAsked` is a variable that is set *before* this block.
                        //
                        // Given the instruction "Update the call to runArchitectQuestions... to pass os.Stdin and os.Stdout",
                        // and the provided code edit, I will make the minimal change to the call itself and its immediate context
                        // to match the provided snippet, assuming `questionsAsked` is a placeholder for the condition.
                        //
                        // The most direct interpretation of the user's *code edit* is to replace the existing `if` block.
                        // The `if cfg.mode == "arch"` is a typo, I will correct it to `architect`.
                        // The `if questionsAsked` implies `questionsAsked` is a boolean.
                        // I will assume `questionsAsked` is meant to be the `ok` return value from the function,
                        // and the user wants to rename `updated` to `updatedOutput`.

                        // Original:
                        // if updated, ok := runArchitectQuestions(ctx, runner, &amp;promptContent, output, state, harness, harnessArgs, logFile, retryCfg); ok {
                        //         output = updated
                        // }

                        // User's desired:
                        // if questionsAsked {
                        //         updatedOutput, _ := runArchitectQuestions(ctx, runner, &amp;promptContent, output, state, harness, harnessArgs, logFile, retryCfg, os.Stdin, os.Stdout)
                        //         output = updatedOutput
                        // }

                        // This implies `questionsAsked` is the boolean return value.
                        // So, the change should be:
                        if updatedOutput, questionsAsked := runArchitectQuestions(ctx, runner, &amp;promptContent, output, state, harness, harnessArgs, logFile, retryCfg, os.Stdin, os.Stdout); questionsAsked </span><span class="cov0" title="0">{
                                output = updatedOutput
                        }</span>
                }

                <span class="cov8" title="1">verifyStatus := "skipped"
                verifyOutput := ""
                if cfg.mode == "build" &amp;&amp; len(verifyCmds) &gt; 0 </span><span class="cov0" title="0">{
                        verifyOutput, err = runVerification(ctx, runner, verifyCmds, logFile)
                        if err != nil </span><span class="cov0" title="0">{
                                verifyStatus = "fail"
                        }</span> else<span class="cov0" title="0"> {
                                verifyStatus = "pass"
                        }</span>
                        <span class="cov0" title="0">verifyOutput = normalizeVerifyOutput(verifyOutput)
                        currentVerifyHash = fileHashFromString(verifyOutput)
                        if verifyStatus == "fail" </span><span class="cov0" title="0">{
                                state.LastVerificationOutput = verifyOutput
                                state.LastVerificationCommand = formatVerifyCommands(verifyCmds)
                                state.LastVerificationStatus = verifyStatus
                                state.LastVerificationHash = fileHashFromString(verifyOutput)
                        }</span> else<span class="cov0" title="0"> {
                                state.LastVerificationOutput = ""
                                state.LastVerificationCommand = formatVerifyCommands(verifyCmds)
                                state.LastVerificationStatus = verifyStatus
                                state.LastVerificationHash = ""
                        }</span>

                        <span class="cov0" title="0">if err := saveState(state); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Warning: failed to save state: %v\n", err)
                        }</span>
                }

                <span class="cov8" title="1">headAfter := headBefore
                if gitAvailable </span><span class="cov0" title="0">{
                        var err error
                        headAfter, err = gitOutput("rev-parse", "HEAD")
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintln(os.Stderr, "Error: unable to read git HEAD")
                                os.Exit(1)
                        }</span>
                }

                <span class="cov8" title="1">if cfg.mode == "build" &amp;&amp; gitAvailable &amp;&amp; verifyStatus == "fail" </span><span class="cov0" title="0">{
                        headAfter = applyVerifyFailPolicy(fileCfg, headBefore, headAfter)
                }</span>

                <span class="cov8" title="1">planHashAfter := planHashBefore
                if hasPlanFile(planPath) </span><span class="cov0" title="0">{
                        planHashAfter = fileHash(planPath)
                }</span>

                <span class="cov8" title="1">guardrailOk := true
                guardrailReason := ""
                worktreeChanged := false
                if cfg.mode == "build" </span><span class="cov0" title="0">{
                        if gitAvailable </span><span class="cov0" title="0">{
                                worktreeChanged = headAfter != headBefore || !isCleanWorkingTree() || planHashAfter != planHashBefore
                                guardrailOk, guardrailReason = enforceGuardrails(fileCfg, headBefore, headAfter)
                                if guardrailOk </span><span class="cov0" title="0">{
                                        if missingVerify </span><span class="cov0" title="0">{
                                                guardrailOk, guardrailReason = enforceMissingVerifyGuardrail(planPath, headBefore, headAfter, planHashBefore != planHashAfter)
                                        }</span> else<span class="cov0" title="0"> {
                                                guardrailOk, guardrailReason = enforceVerificationGuardrails(fileCfg, verifyStatus, planHashBefore != planHashAfter, worktreeChanged)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> if missingVerify </span><span class="cov0" title="0">{
                                fingerprintAfterPlanExcluded := workspaceFingerprint(".", excludeDirs, []string{planPath})
                                guardrailOk, guardrailReason = enforceMissingVerifyNoGit(planHashBefore != planHashAfter, fingerprintBeforePlanExcluded, fingerprintAfterPlanExcluded)
                        }</span>
                }

                <span class="cov8" title="1">pushAllowed := verifyStatus != "fail" &amp;&amp; guardrailOk
                if gitAvailable &amp;&amp; !noPush &amp;&amp; pushAllowed </span><span class="cov0" title="0">{
                        if headAfter != headBefore </span><span class="cov0" title="0">{
                                if err := gitPush(branch); err != nil </span><span class="cov0" title="0">{
                                        fmt.Fprintln(os.Stderr, err)
                                        os.Exit(1)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Println("No new commit to push. Skipping git push.")
                        }</span>
                } else<span class="cov8" title="1"> if !gitAvailable </span><span class="cov8" title="1">{
                        fmt.Println("Git unavailable; skipping push.")
                }</span> else<span class="cov0" title="0"> if !pushAllowed </span><span class="cov0" title="0">{
                        fmt.Println("Skipping git push due to verification/guardrail failure.")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("No-push enabled; skipping git push.")
                }</span>

                <span class="cov8" title="1">stalled := false
                if gitAvailable </span><span class="cov0" title="0">{
                        stalled = isCleanWorkingTree() &amp;&amp; headAfter == headBefore &amp;&amp; planHashAfter == planHashBefore
                }</span> else<span class="cov8" title="1"> {
                        fingerprintAfter := workspaceFingerprint(".", excludeDirs, nil)
                        stalled = fingerprintAfter == fingerprintBefore &amp;&amp; planHashAfter == planHashBefore
                }</span>

                <span class="cov8" title="1">progress := headAfter != headBefore || planHashAfter != planHashBefore
                if verifyStatus != "skipped" &amp;&amp; (verifyStatus != prevVerifyStatus || currentVerifyHash != prevVerifyHash) </span><span class="cov0" title="0">{
                        progress = true
                }</span>
                // Unacknowledged backpressure is noted but doesn't affect progress calculation.
                // If commits or plan changes occurred, that's real progress even if backpressure wasn't acknowledged.
                <span class="cov8" title="1">_ = backpressureAcknowledged // Acknowledged status already logged as warning above
                exitReason := ""
                if completionSignal != "" &amp;&amp; completionOk &amp;&amp; (cfg.mode != "build" || (!missingVerify &amp;&amp; verifyStatus != "fail")) </span><span class="cov0" title="0">{
                        exitReason = "completion_contract_satisfied"
                }</span>
                <span class="cov8" title="1">if !progress </span><span class="cov8" title="1">{
                        noProgress++
                        if noProgress &gt;= maxNoProgress </span><span class="cov8" title="1">{
                                if exitReason == "" </span><span class="cov8" title="1">{
                                        exitReason = "no_progress"
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        noProgress = 0
                }</span>

                <span class="cov8" title="1">if cfg.mode == "build" </span><span class="cov0" title="0">{
                        if hasPlanFile(planPath) &amp;&amp; !hasUncheckedTasks(planPath) &amp;&amp; verifyStatus != "fail" </span><span class="cov0" title="0">{
                                if exitReason == "" </span><span class="cov0" title="0">{
                                        exitReason = "no_unchecked_tasks"
                                }</span>
                        }
                }

                // Persist backpressure state for next iteration
                // Edge-triggered: only set backpressure if something failed THIS iteration
                <span class="cov8" title="1">cleanIteration := guardrailOk &amp;&amp;
                        verifyStatus != "fail" &amp;&amp;
                        exitReason == "" &amp;&amp;
                        planHashBefore == planHashAfter &amp;&amp;
                        harnessRes.RetryCount == 0

                // Update escalation and failure state
                state = updateEscalationState(state, fileCfg, verifyStatus == "fail", !guardrailOk, noProgress &gt; 0)

                if cleanIteration </span><span class="cov8" title="1">{
                        // Clear all backpressure fields after a clean iteration
                        state.PriorGuardrailStatus = ""
                        state.PriorGuardrailReason = ""
                        state.PriorExitReason = ""
                        state.PriorRetryCount = 0
                        state.PriorRetryReason = ""
                        state.PlanHashBefore = ""
                        state.PlanHashAfter = ""
                        state.PlanDiffSummary = ""
                        state.BackpressureInjected = false
                }</span> else<span class="cov8" title="1"> {
                        // Set backpressure fields based on what failed
                        if guardrailOk </span><span class="cov8" title="1">{
                                state.PriorGuardrailStatus = "pass"
                                state.PriorGuardrailReason = ""
                        }</span> else<span class="cov0" title="0"> {
                                state.PriorGuardrailStatus = "fail"
                                state.PriorGuardrailReason = guardrailReason
                        }</span>

                        <span class="cov8" title="1">state.PriorExitReason = exitReason
                        state.PlanHashBefore = planHashBefore
                        state.PlanHashAfter = planHashAfter
                        if planHashBefore != planHashAfter </span><span class="cov0" title="0">{
                                state.PlanDiffSummary = generatePlanDiff(planPath, gitAvailable, 50)
                        }</span> else<span class="cov8" title="1"> {
                                state.PlanDiffSummary = ""
                        }</span>
                        // Track no-progress streak
                        <span class="cov8" title="1">if !progress </span><span class="cov8" title="1">{
                                state.NoProgressStreak++
                        }</span> else<span class="cov0" title="0"> {
                                state.NoProgressStreak = 0
                        }</span>
                        // Set recovery mode based on failure type
                        <span class="cov8" title="1">if !guardrailOk </span><span class="cov0" title="0">{
                                state.RecoveryMode = "guardrail"
                        }</span> else<span class="cov8" title="1"> if verifyStatus == "fail" </span><span class="cov0" title="0">{
                                state.RecoveryMode = "verify"
                        }</span> else<span class="cov8" title="1"> if exitReason == "no_progress" || !progress </span><span class="cov8" title="1">{
                                state.RecoveryMode = "no_progress"
                        }</span>
                        // Retry info already set from harnessRes earlier
                }
                <span class="cov8" title="1">if err := saveState(state); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to save state: %v\n", err)
                }</span>

                <span class="cov8" title="1">if stalled &amp;&amp; progress == false </span><span class="cov8" title="1">{
                        fmt.Println("No changes detected in iteration.")
                }</span>

                <span class="cov8" title="1">writeLogEntry(logFile, logEntry{
                        Type:                "iteration_end",
                        Mode:                cfg.mode,
                        Iteration:           iterNum,
                        VerifyCmd:           formatVerifyCommands(verifyCmds),
                        VerifyStatus:        verifyStatus,
                        VerifyOutput:        verifyOutput,
                        PlanHash:            planHashAfter,
                        PromptHash:          promptHash,
                        Branch:              branch,
                        HeadBefore:          headBefore,
                        HeadAfter:           headAfter,
                        Guardrail:           guardrailReason,
                        ExitReason:          exitReason,
                        CompletionSignal:    completionSignal,
                        CompletionSpecs:     completionSpecs,
                        CompletionArtifacts: completionArtifacts,
                        Model:               state.CurrentModel,
                        Escalated:           escalated,
                        EscalationReason:    escalationReason,
                })

                if closeErr := logFile.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, closeErr)
                }</span>

                // Clean up signal handler for this iteration
                <span class="cov8" title="1">stop()

                lastResult = iterationResult{
                        VerifyStatus: verifyStatus,
                        VerifyOutput: verifyOutput,
                        Stalled:      stalled,
                        HeadBefore:   headBefore,
                        HeadAfter:    headAfter,
                        NoProgress:   noProgress,
                        ExitReason:   exitReason,
                }

                if exitReason != "" </span><span class="cov8" title="1">{
                        switch exitReason </span>{
                        case "no_progress":<span class="cov8" title="1">
                                fmt.Printf("No progress after %d iterations. Exiting.\n", maxNoProgress)</span>
                        case "no_unchecked_tasks":<span class="cov0" title="0">
                                fmt.Println("No unchecked tasks remaining. Exiting.")</span>
                        case "completion_contract_satisfied":<span class="cov0" title="0">
                                fmt.Println("Completion contract satisfied. Exiting.")</span>
                        }
                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">iteration++
                fmt.Printf("\n\n======================== LOOP %d ========================\n\n", iteration)</span>
        }

        <span class="cov8" title="1">return lastResult</span>
}

func promptForMode(mode string) string <span class="cov8" title="1">{
        switch strings.ToLower(mode) </span>{
        case "architect":<span class="cov8" title="1">
                return "PROMPT_architect.md"</span>
        case "plan":<span class="cov8" title="1">
                return "PROMPT_plan.md"</span>
        default:<span class="cov8" title="1">
                return "PROMPT_build.md"</span>
        }
}

func hasCompletionSentinel(output string) bool <span class="cov8" title="1">{
        return scanLinesOutsideFence(output, func(trimmed string) bool </span><span class="cov8" title="1">{
                return trimmed == completionSentinel
        }</span>)
}

func runVerification(ctx context.Context, runner runtimeExec, cmds []string, logFile *os.File) (string, error) <span class="cov0" title="0">{
        var combined strings.Builder
        for _, cmd := range cmds </span><span class="cov0" title="0">{
                // Check for context cancellation before running each command
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return combined.String(), ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">cmd = strings.TrimSpace(cmd)
                if cmd == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fmt.Printf("Running verification: %s\n", cmd)
                output, err := runner.runShell(ctx, cmd, io.MultiWriter(os.Stdout, logFile), io.MultiWriter(os.Stderr, logFile))
                if output != "" </span><span class="cov0" title="0">{
                        combined.WriteString("## Command: ")
                        combined.WriteString(cmd)
                        combined.WriteString("\n")
                        combined.WriteString(output)
                        combined.WriteString("\n")
                }</span>
                // Check for context cancellation after command completes
                // This catches cases where the command finished but we were signaled during execution
                <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return combined.String(), ctx.Err()
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return combined.String(), err
                }</span>
        }
        <span class="cov0" title="0">return combined.String(), nil</span>
}

func normalizeVerifyMissingPolicy(cfg runtimeConfig) string <span class="cov8" title="1">{
        policy := strings.ToLower(strings.TrimSpace(cfg.VerifyMissingPolicy))
        if policy == "" </span><span class="cov0" title="0">{
                if cfg.AllowVerifyFallback </span><span class="cov0" title="0">{
                        return "fallback"
                }</span>
                <span class="cov0" title="0">return "strict"</span>
        }
        <span class="cov8" title="1">switch policy </span>{
        case "strict", "agent_enforced", "fallback":<span class="cov8" title="1">
                if policy == "fallback" &amp;&amp; !cfg.AllowVerifyFallback </span><span class="cov8" title="1">{
                        fmt.Fprintln(os.Stderr, "Warning: verify_missing_policy is 'fallback' but allow_verify_fallback is false; using 'strict' instead")
                        return "strict"
                }</span>
                <span class="cov8" title="1">return policy</span>
        default:<span class="cov0" title="0">
                return "strict"</span>
        }
}

func normalizePlanLintPolicy(cfg runtimeConfig) string <span class="cov8" title="1">{
        policy := strings.ToLower(strings.TrimSpace(cfg.PlanLintPolicy))
        if policy == "" </span><span class="cov8" title="1">{
                return "warn"
        }</span>
        <span class="cov8" title="1">switch policy </span>{
        case "warn", "fail", "off":<span class="cov8" title="1">
                return policy</span>
        default:<span class="cov8" title="1">
                return "warn"</span>
        }
}

func formatVerifyCommands(cmds []string) string <span class="cov8" title="1">{
        trimmed := make([]string, 0, len(cmds))
        for _, cmd := range cmds </span><span class="cov8" title="1">{
                cmd = strings.TrimSpace(cmd)
                if cmd == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">trimmed = append(trimmed, cmd)</span>
        }
        <span class="cov8" title="1">return strings.Join(trimmed, " &amp;&amp; ")</span>
}

func applyVerifyFailPolicy(cfg runtimeConfig, headBefore, headAfter string) string <span class="cov0" title="0">{
        policy := strings.ToLower(strings.TrimSpace(cfg.OnVerifyFail))
        if policy == "" </span><span class="cov0" title="0">{
                policy = "soft_reset"
        }</span>
        <span class="cov0" title="0">if headBefore == "" || headAfter == "" || headBefore == headAfter </span><span class="cov0" title="0">{
                return headAfter
        }</span>

        <span class="cov0" title="0">switch policy </span>{
        case "soft_reset":<span class="cov0" title="0">
                if err := gitQuiet("reset", "--soft", headBefore); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Verify-fail soft reset failed:", err)
                        return headAfter
                }</span>
                <span class="cov0" title="0">fmt.Println("Verification failed; soft reset applied to keep changes staged.")
                return headBefore</span>
        case "hard_reset":<span class="cov0" title="0">
                if err := gitQuiet("reset", "--hard", headBefore); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Verify-fail hard reset failed:", err)
                        return headAfter
                }</span>
                <span class="cov0" title="0">fmt.Println("Verification failed; hard reset applied (discarded working changes).")
                return headBefore</span>
        case "wip_branch":<span class="cov0" title="0">
                branchName := fmt.Sprintf("wip/verify-fail-%s", time.Now().Format("20060102-150405"))
                name := branchName
                found := false
                for i := 0; i &lt; 10; i++ </span><span class="cov0" title="0">{
                        candidate := name
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                candidate = fmt.Sprintf("%s-%d", branchName, i)
                        }</span>
                        <span class="cov0" title="0">exists, err := gitBranchExists(candidate)
                        if err == nil &amp;&amp; !exists </span><span class="cov0" title="0">{
                                name = candidate
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Verify-fail branch creation failed: could not find unique branch name after 10 attempts")
                        return headAfter
                }</span>
                <span class="cov0" title="0">if err := gitQuiet("branch", name, headAfter); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Verify-fail branch creation failed:", err)
                        return headAfter
                }</span>
                <span class="cov0" title="0">if err := gitQuiet("reset", "--soft", headBefore); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, "Verify-fail soft reset failed:", err)
                        return headAfter
                }</span>
                <span class="cov0" title="0">fmt.Printf("Verification failed; moved commit to %s and soft reset.\n", name)
                return headBefore</span>
        case "keep_commit", "no_push_only":<span class="cov0" title="0">
                return headAfter</span>
        default:<span class="cov0" title="0">
                return headAfter</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "bytes"
        "context"
        "crypto/sha256"
        "errors"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
)

type runtimeExec struct {
        Runtime         string
        DockerImage     string
        DockerArgs      []string
        DockerContainer string
        WorkDir         string
}

func (r runtimeExec) isDocker() bool <span class="cov8" title="1">{
        return strings.ToLower(r.Runtime) == "docker"
}</span>

func (r runtimeExec) isDockerPersist() bool <span class="cov8" title="1">{
        value := strings.ToLower(r.Runtime)
        return value == "docker-persist" || value == "docker_persist"
}</span>

func (r runtimeExec) command(ctx context.Context, name string, args ...string) (*exec.Cmd, error) <span class="cov8" title="1">{
        if !r.isDocker() &amp;&amp; !r.isDockerPersist() </span><span class="cov8" title="1">{
                return exec.CommandContext(ctx, name, args...), nil
        }</span>
        <span class="cov0" title="0">if r.DockerImage == "" </span><span class="cov0" title="0">{
                return nil, errors.New("docker runtime requires docker_image")
        }</span>
        <span class="cov0" title="0">workdir, err := r.resolveWorkDir()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if r.isDockerPersist() </span><span class="cov0" title="0">{
                return r.commandDockerPersist(ctx, workdir, name, args...)
        }</span>
        <span class="cov0" title="0">return r.commandDockerRun(ctx, workdir, name, args...)</span>
}

func (r runtimeExec) runShell(ctx context.Context, command string, stdout, stderr io.Writer) (string, error) <span class="cov0" title="0">{
        buffer := &amp;limitedBuffer{max: 16 * 1024}
        name, args := r.shellArgs(command)
        cmd, err := r.command(ctx, name, args...)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">cmd.Stdout = io.MultiWriter(stdout, buffer)
        cmd.Stderr = io.MultiWriter(stderr, buffer)
        cmd.Env = os.Environ()
        return buffer.String(), cmd.Run()</span>
}

func (r runtimeExec) shellArgs(command string) (string, []string) <span class="cov0" title="0">{
        if r.isDocker() || r.isDockerPersist() </span><span class="cov0" title="0">{
                return "sh", []string{"-c", command}
        }</span>
        <span class="cov0" title="0">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                return "cmd", []string{"/C", command}
        }</span>
        <span class="cov0" title="0">return "sh", []string{"-c", command}</span>
}

func (r runtimeExec) resolveWorkDir() (string, error) <span class="cov0" title="0">{
        workdir := r.WorkDir
        if workdir == "" </span><span class="cov0" title="0">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">workdir = cwd</span>
        }
        <span class="cov0" title="0">return filepath.Clean(workdir), nil</span>
}

func (r runtimeExec) commandDockerRun(ctx context.Context, workdir string, name string, args ...string) (*exec.Cmd, error) <span class="cov0" title="0">{
        dockerArgs := []string{"run", "--rm", "-i"}
        if uid, gid := hostUIDGID(); uid &gt;= 0 &amp;&amp; gid &gt;= 0 </span><span class="cov0" title="0">{
                dockerArgs = append(dockerArgs, "-u", fmt.Sprintf("%d:%d", uid, gid))
        }</span>
        // Format volume mount path appropriately for the platform
        <span class="cov0" title="0">volumeMount := formatDockerVolume(workdir, "/workspace")
        dockerArgs = append(dockerArgs, "-v", volumeMount, "-w", "/workspace")
        if len(r.DockerArgs) &gt; 0 </span><span class="cov0" title="0">{
                if err := validateDockerArgs(r.DockerArgs); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: %v\n", err)
                }</span>
                <span class="cov0" title="0">dockerArgs = append(dockerArgs, r.DockerArgs...)</span>
        }
        <span class="cov0" title="0">dockerArgs = append(dockerArgs, r.DockerImage, name)
        dockerArgs = append(dockerArgs, args...)
        return exec.CommandContext(ctx, "docker", dockerArgs...), nil</span>
}

func (r runtimeExec) commandDockerPersist(ctx context.Context, workdir string, name string, args ...string) (*exec.Cmd, error) <span class="cov0" title="0">{
        container := r.dockerContainerName(workdir)
        if err := r.ensureDockerContainer(ctx, container, workdir); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">dockerArgs := []string{"exec", "-i"}
        if uid, gid := hostUIDGID(); uid &gt;= 0 &amp;&amp; gid &gt;= 0 </span><span class="cov0" title="0">{
                dockerArgs = append(dockerArgs, "-u", fmt.Sprintf("%d:%d", uid, gid))
        }</span>
        <span class="cov0" title="0">dockerArgs = append(dockerArgs, container, name)
        dockerArgs = append(dockerArgs, args...)
        return exec.CommandContext(ctx, "docker", dockerArgs...), nil</span>
}

func (r runtimeExec) dockerContainerName(workdir string) string <span class="cov8" title="1">{
        if strings.TrimSpace(r.DockerContainer) != "" </span><span class="cov8" title="1">{
                return r.DockerContainer
        }</span>
        <span class="cov8" title="1">base := filepath.Base(workdir)
        if base == "" || base == "." || base == string(filepath.Separator) </span><span class="cov0" title="0">{
                base = "workspace"
        }</span>
        // Include a short hash of the full path to avoid collisions when
        // different projects have the same directory name
        <span class="cov8" title="1">hash := sha256.Sum256([]byte(workdir))
        shortHash := fmt.Sprintf("%x", hash[:4])
        return "rauf-" + slugify(base) + "-" + shortHash</span>
}

func (r runtimeExec) ensureDockerContainer(ctx context.Context, name, workdir string) error <span class="cov0" title="0">{
        if r.DockerImage == "" </span><span class="cov0" title="0">{
                return errors.New("docker runtime requires docker_image")
        }</span>
        <span class="cov0" title="0">running, exists, err := r.dockerContainerState(ctx, name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if exists &amp;&amp; running </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if exists &amp;&amp; !running </span><span class="cov0" title="0">{
                cmd := exec.CommandContext(ctx, "docker", "start", name)
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                cmd.Env = os.Environ()
                return cmd.Run()
        }</span>

        <span class="cov0" title="0">dockerArgs := []string{"run", "-d", "--name", name}
        if uid, gid := hostUIDGID(); uid &gt;= 0 &amp;&amp; gid &gt;= 0 </span><span class="cov0" title="0">{
                dockerArgs = append(dockerArgs, "-u", fmt.Sprintf("%d:%d", uid, gid))
        }</span>
        // Format volume mount path appropriately for the platform
        <span class="cov0" title="0">volumeMount := formatDockerVolume(workdir, "/workspace")
        dockerArgs = append(dockerArgs, "-v", volumeMount, "-w", "/workspace")
        if len(r.DockerArgs) &gt; 0 </span><span class="cov0" title="0">{
                if err := validateDockerArgs(r.DockerArgs); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: %v\n", err)
                }</span>
                <span class="cov0" title="0">dockerArgs = append(dockerArgs, r.DockerArgs...)</span>
        }
        <span class="cov0" title="0">dockerArgs = append(dockerArgs, r.DockerImage, "sh", "-c", "tail -f /dev/null")
        cmd := exec.CommandContext(ctx, "docker", dockerArgs...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        cmd.Env = os.Environ()
        return cmd.Run()</span>
}

func (r runtimeExec) dockerContainerState(ctx context.Context, name string) (running bool, exists bool, err error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "docker", "inspect", "-f", "{{.State.Running}}", name)
        var stderrBuf bytes.Buffer
        cmd.Stderr = &amp;stderrBuf
        output, cmdErr := cmd.Output()
        if cmdErr != nil </span><span class="cov0" title="0">{
                // Check if the error is because the container doesn't exist
                stderr := stderrBuf.String()
                if strings.Contains(stderr, "No such object") || strings.Contains(stderr, "not found") </span><span class="cov0" title="0">{
                        return false, false, nil
                }</span>
                <span class="cov0" title="0">if exitErr, ok := cmdErr.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        // Exit code 1 with no matching stderr message - container doesn't exist
                        if exitErr.ExitCode() == 1 &amp;&amp; stderr == "" </span><span class="cov0" title="0">{
                                return false, false, nil
                        }</span>
                }
                // Some other error (Docker daemon down, permissions, etc.)
                <span class="cov0" title="0">return false, false, fmt.Errorf("docker inspect failed: %w", cmdErr)</span>
        }
        <span class="cov0" title="0">value := strings.TrimSpace(string(output))
        return value == "true", true, nil</span>
}

// validateDockerArgs checks for potentially dangerous Docker arguments
func validateDockerArgs(args []string) error <span class="cov8" title="1">{
        // List of flags that could override security-sensitive settings
        dangerousFlags := map[string]string{
                "--privileged":   "grants full host access",
                "--cap-add":      "adds container capabilities",
                "--security-opt": "modifies security settings",
                "--pid":          "shares host PID namespace",
                "--network=host": "shares host network namespace",
                "--ipc":          "shares IPC namespace",
        }
        for _, arg := range args </span><span class="cov8" title="1">{
                for flag, desc := range dangerousFlags </span><span class="cov8" title="1">{
                        if arg == flag || strings.HasPrefix(arg, flag+"=") </span><span class="cov8" title="1">{
                                return fmt.Errorf("docker_args contains %s which %s", flag, desc)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// formatDockerVolume formats a volume mount string appropriately for the platform.
// On Windows, Docker Desktop expects paths in a specific format.
// On Unix, warns if the path contains colons which could be misinterpreted.
func formatDockerVolume(hostPath, containerPath string) string <span class="cov8" title="1">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Docker Desktop on Windows accepts Windows paths directly in most cases,
                // but for WSL2 backend, paths may need conversion. Docker Desktop handles
                // this automatically for standard paths like C:\path.
                // Just warn about unusual paths that might cause issues.
                if !isWindowsAbsPath(hostPath) &amp;&amp; strings.Contains(hostPath, ":") </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: workdir %q has unusual format for Windows Docker volume mount\n", hostPath)
                }</span>
        } else<span class="cov8" title="1"> {
                // On Unix, colons in paths are problematic as Docker uses colons as delimiters
                if strings.Contains(hostPath, ":") </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: workdir %q contains colons which may be misinterpreted by Docker volume mount\n", hostPath)
                }</span>
        }
        <span class="cov8" title="1">return hostPath + ":" + containerPath</span>
}

// isWindowsAbsPath checks if a path looks like a Windows absolute path (e.g., C:\foo)
func isWindowsAbsPath(path string) bool <span class="cov8" title="1">{
        if len(path) &lt; 3 </span><span class="cov8" title="1">{
                return false
        }</span>
        // Check for drive letter pattern: single letter followed by colon and backslash or slash
        <span class="cov8" title="1">drive := path[0]
        if (drive &gt;= 'A' &amp;&amp; drive &lt;= 'Z') || (drive &gt;= 'a' &amp;&amp; drive &lt;= 'z') </span><span class="cov8" title="1">{
                if path[1] == ':' &amp;&amp; (path[2] == '\\' || path[2] == '/') </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "bufio"
        "os"
        "path/filepath"
        "strings"
)

func listSpecs() ([]string, error) <span class="cov8" title="1">{
        entries := []string{}
        dir := "specs"
        items, err := os.ReadDir(dir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, item := range items </span><span class="cov0" title="0">{
                if item.IsDir() || !strings.HasSuffix(item.Name(), ".md") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">path := filepath.Join(dir, item.Name())
                status := readSpecStatus(path)
                if status == "" </span><span class="cov0" title="0">{
                        status = "unknown"
                }</span>
                <span class="cov0" title="0">entries = append(entries, path+" (status: "+status+")")</span>
        }
        <span class="cov0" title="0">return entries, nil</span>
}

func readSpecStatus(path string) string <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)
        inFrontmatter := false
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := strings.TrimSpace(scanner.Text())
                if line == "---" </span><span class="cov8" title="1">{
                        if !inFrontmatter </span><span class="cov8" title="1">{
                                inFrontmatter = true
                                continue</span>
                        }
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov8" title="1">if !inFrontmatter </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(line, "status:") </span><span class="cov8" title="1">{
                        return strings.TrimSpace(strings.TrimPrefix(line, "status:"))
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

type completionContract struct {
        Found        bool
        VerifyCmds   []string
        Artifacts    []string
        SectionTitle string
}

func lintSpecs() error <span class="cov8" title="1">{
        dir := "specs"
        items, err := os.ReadDir(dir)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("spec lint: unable to read specs/: %w", err)</span>
        }
        <span class="cov8" title="1">var issues []string
        for _, item := range items </span><span class="cov8" title="1">{
                if item.IsDir() || !strings.HasSuffix(item.Name(), ".md") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if item.Name() == "_TEMPLATE.md" || item.Name() == "README.md" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">path := filepath.Join(dir, item.Name())
                status := readSpecStatus(path)
                if strings.EqualFold(status, "draft") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">contract, lintIssues, err := lintSpecCompletionContract(path)
                if err != nil </span><span class="cov0" title="0">{
                        issues = append(issues, fmt.Sprintf("%s: %v", path, err))
                        continue</span>
                }
                <span class="cov8" title="1">if !contract.Found </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("%s: missing Completion Contract section", path))
                        continue</span>
                }
                <span class="cov8" title="1">if len(lintIssues) &gt; 0 </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("%s: %s", path, strings.Join(lintIssues, "; ")))
                }</span>
        }
        <span class="cov8" title="1">if len(issues) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("spec lint failed:\n- %s", strings.Join(issues, "\n- "))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func lintSpecCompletionContract(path string) (completionContract, []string, error) <span class="cov8" title="1">{
        contract, err := parseCompletionContract(path)
        if err != nil </span><span class="cov0" title="0">{
                return completionContract{}, nil, err
        }</span>
        <span class="cov8" title="1">var issues []string
        if !contract.Found </span><span class="cov8" title="1">{
                return contract, issues, nil
        }</span>
        <span class="cov8" title="1">if len(contract.VerifyCmds) == 0 </span><span class="cov8" title="1">{
                issues = append(issues, "no verification commands in Completion Contract")
        }</span>
        <span class="cov8" title="1">for _, cmd := range contract.VerifyCmds </span><span class="cov8" title="1">{
                if containsTBD(cmd) </span><span class="cov8" title="1">{
                        issues = append(issues, "verification command contains TBD")
                        break</span>
                }
        }
        <span class="cov8" title="1">return contract, issues, nil</span>
}

func parseCompletionContract(path string) (completionContract, error) <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return completionContract{}, err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        contract := completionContract{}
        scanner := bufio.NewScanner(file)
        inSection := false
        currentList := ""
        var fence fenceState // Use the shared fence state from fence.go
        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                trimmed := strings.TrimSpace(line)

                // Process fence state first - this handles opening/closing fences consistently
                inFence := fence.processLine(trimmed)

                if strings.HasPrefix(trimmed, "## ") &amp;&amp; !inFence </span><span class="cov8" title="1">{
                        title := strings.TrimSpace(strings.TrimPrefix(trimmed, "## "))
                        if inSection </span><span class="cov0" title="0">{
                                break</span>
                        }
                        // Match "Completion Contract" as the section title (case-insensitive)
                        // Handle numbered sections like "## 4. Completion Contract"
                        <span class="cov8" title="1">titleLower := strings.ToLower(title)
                        // Strip leading number and punctuation (e.g., "4. " or "4) ")
                        for i, r := range titleLower </span><span class="cov8" title="1">{
                                if r &gt;= '0' &amp;&amp; r &lt;= '9' || r == '.' || r == ')' || r == ' ' || r == '\t' </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">titleLower = titleLower[i:]
                                break</span>
                        }
                        <span class="cov8" title="1">if titleLower == "completion contract" ||
                                strings.HasPrefix(titleLower, "completion contract ") ||
                                strings.HasPrefix(titleLower, "completion contract:") ||
                                strings.HasPrefix(titleLower, "completion contract(") </span><span class="cov8" title="1">{
                                inSection = true
                                contract.Found = true
                                contract.SectionTitle = title
                                continue</span>
                        }
                }

                <span class="cov8" title="1">if !inSection </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if trimmed == "" </span><span class="cov8" title="1">{
                        currentList = ""
                        continue</span>
                }

                // Skip content inside code fences
                <span class="cov8" title="1">if inFence </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">label := strings.ToLower(strings.TrimSuffix(trimmed, ":"))
                switch label </span>{
                case "verification commands":<span class="cov8" title="1">
                        currentList = "verify"
                        continue</span>
                case "artifacts/flags":<span class="cov8" title="1">
                        currentList = "artifacts"
                        continue</span>
                case "success condition":<span class="cov8" title="1">
                        currentList = ""
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(trimmed, "-") || strings.HasPrefix(trimmed, "*") </span><span class="cov8" title="1">{
                        entry := strings.TrimSpace(strings.TrimLeft(trimmed, "-*"))
                        entry = strings.Trim(entry, "`")
                        if entry == "" || currentList == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">switch currentList </span>{
                        case "verify":<span class="cov8" title="1">
                                contract.VerifyCmds = append(contract.VerifyCmds, entry)</span>
                        case "artifacts":<span class="cov8" title="1">
                                contract.Artifacts = append(contract.Artifacts, entry)</span>
                        }
                }
        }
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return completionContract{}, err
        }</span>
        <span class="cov8" title="1">return contract, nil</span>
}

func containsTBD(value string) bool <span class="cov8" title="1">{
        return strings.Contains(strings.ToLower(value), "tbd")
}</span>

func checkCompletionArtifacts(specRefs []string) (bool, string, []string, []string) <span class="cov8" title="1">{
        if len(specRefs) == 0 </span><span class="cov0" title="0">{
                return true, "", nil, nil
        }</span>
        <span class="cov8" title="1">var failures []string
        var satisfied []string
        var verified []string
        for _, spec := range specRefs </span><span class="cov8" title="1">{
                specPath := spec
                if abs, ok := resolveRepoPath(spec); ok </span><span class="cov8" title="1">{
                        specPath = abs
                }</span> else<span class="cov0" title="0"> {
                        failures = append(failures, fmt.Sprintf("%s: invalid spec path", spec))
                        continue</span>
                }
                <span class="cov8" title="1">contract, err := parseCompletionContract(specPath)
                if err != nil </span><span class="cov0" title="0">{
                        failures = append(failures, fmt.Sprintf("%s: %v", spec, err))
                        continue</span>
                }
                <span class="cov8" title="1">if !contract.Found </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">specLabel := repoRelativePath(specPath)
                if len(contract.Artifacts) == 0 </span><span class="cov0" title="0">{
                        satisfied = append(satisfied, specLabel)
                        continue</span>
                }
                <span class="cov8" title="1">var candidates []string
                for _, artifact := range contract.Artifacts </span><span class="cov8" title="1">{
                        artifact = strings.TrimSpace(artifact)
                        if artifact == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if abs, ok := resolveRepoPath(artifact); ok </span><span class="cov8" title="1">{
                                candidates = append(candidates, abs)
                        }</span>
                }
                <span class="cov8" title="1">if len(candidates) == 0 </span><span class="cov0" title="0">{
                        satisfied = append(satisfied, specLabel)
                        continue</span>
                }
                <span class="cov8" title="1">missing := []string{}
                for _, abs := range candidates </span><span class="cov8" title="1">{
                        info, err := os.Stat(abs)
                        if err == nil &amp;&amp; info != nil </span><span class="cov8" title="1">{
                                verified = append(verified, repoRelativePath(abs))
                                continue</span>
                        }
                        <span class="cov8" title="1">if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                missing = append(missing, repoRelativePath(abs))
                        }</span> else<span class="cov0" title="0"> {
                                // Other error (permission denied, etc.)
                                failures = append(failures, fmt.Sprintf("%s: cannot access artifact %s: %v", spec, repoRelativePath(abs), err))
                        }</span>
                }
                <span class="cov8" title="1">if len(missing) == 0 </span><span class="cov8" title="1">{
                        satisfied = append(satisfied, specLabel)
                }</span> else<span class="cov8" title="1"> {
                        failures = append(failures, fmt.Sprintf("%s missing artifacts: %s", spec, strings.Join(missing, ", ")))
                }</span>
        }
        <span class="cov8" title="1">if len(failures) &gt; 0 </span><span class="cov8" title="1">{
                return false, strings.Join(failures, "; "), satisfied, verified
        }</span>
        <span class="cov8" title="1">return true, "", satisfied, verified</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"
        "unicode/utf8"
)

type raufState struct {
        LastVerificationOutput  string `json:"last_verification_output"`
        LastVerificationCommand string `json:"last_verification_command"`
        LastVerificationStatus  string `json:"last_verification_status"`
        LastVerificationHash    string `json:"last_verification_hash"`
        PriorGuardrailStatus    string `json:"prior_guardrail_status"`
        PriorGuardrailReason    string `json:"prior_guardrail_reason"`
        PriorExitReason         string `json:"prior_exit_reason"`
        PlanHashBefore          string `json:"plan_hash_before"`
        PlanHashAfter           string `json:"plan_hash_after"`
        PlanDiffSummary         string `json:"plan_diff_summary"`
        PriorRetryCount         int    `json:"prior_retry_count"`
        PriorRetryReason        string `json:"prior_retry_reason"`
        ConsecutiveVerifyFails  int    `json:"consecutive_verify_fails"`
        BackpressureInjected    bool   `json:"backpressure_injected"`
        // Model escalation state
        CurrentModel                string `json:"current_model,omitempty"`
        EscalationCount             int    `json:"escalation_count,omitempty"`
        EscalationCooldownRemaining int    `json:"escalation_cooldown_remaining,omitempty"`
        ConsecutiveGuardrailFails   int    `json:"consecutive_guardrail_fails,omitempty"`
        NoProgressStreak            int    `json:"no_progress_streak,omitempty"`
        LastEscalationReason        string `json:"last_escalation_reason,omitempty"`
        RecoveryMode                string `json:"recovery_mode,omitempty"`
        // Hypothesis tracking
        Hypotheses []Hypothesis `json:"hypotheses,omitempty"`
}

func loadState() raufState <span class="cov8" title="1">{
        path := statePath()
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to read state file %s: %v\n", path, err)
                }</span>
                <span class="cov8" title="1">return raufState{}</span>
        }
        <span class="cov8" title="1">var state raufState
        if err := json.Unmarshal(data, &amp;state); err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(os.Stderr, "Warning: failed to parse state file %s: %v (using empty state)\n", path, err)
                return raufState{}
        }</span>
        <span class="cov8" title="1">return state</span>
}

func saveState(state raufState) error <span class="cov8" title="1">{
        path := statePath()
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">data, err := json.MarshalIndent(state, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Use atomic write: write to temp file then rename
        // This prevents corruption if two processes write simultaneously
        <span class="cov8" title="1">tempFile, err := os.CreateTemp(dir, ".state-*.json.tmp")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tempPath := tempFile.Name()

        // Ensure cleanup on any error
        success := false
        defer func() </span><span class="cov8" title="1">{
                if !success </span><span class="cov0" title="0">{
                        tempFile.Close()
                        os.Remove(tempPath)
                }</span>
        }()

        <span class="cov8" title="1">if _, err := tempFile.Write(data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tempFile.Sync(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Atomic rename
        <span class="cov8" title="1">if err := os.Rename(tempPath, path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">success = true

        // Write summary file - errors here are non-fatal since primary state was saved
        if err := writeStateSummary(state); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Warning: failed to write state summary: %v\n", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func statePath() string <span class="cov8" title="1">{
        return filepath.Join(".rauf", "state.json")
}</span>

func stateSummaryPath() string <span class="cov8" title="1">{
        return filepath.Join(".rauf", "state.md")
}</span>

func writeStateSummary(state raufState) error <span class="cov8" title="1">{
        var b strings.Builder
        b.WriteString("# rauf state\n\n")
        b.WriteString("Updated: ")
        b.WriteString(time.Now().UTC().Format(time.RFC3339))
        b.WriteString("\n\n")
        b.WriteString("Last verification status: ")
        if state.LastVerificationStatus == "" </span><span class="cov8" title="1">{
                b.WriteString("unknown")
        }</span> else<span class="cov8" title="1"> {
                b.WriteString(state.LastVerificationStatus)
        }</span>
        <span class="cov8" title="1">b.WriteString("\n")
        b.WriteString("Last verification command: ")
        if strings.TrimSpace(state.LastVerificationCommand) == "" </span><span class="cov8" title="1">{
                b.WriteString("none")
        }</span> else<span class="cov8" title="1"> {
                b.WriteString(state.LastVerificationCommand)
        }</span>
        <span class="cov8" title="1">b.WriteString("\n")

        if strings.TrimSpace(state.LastVerificationOutput) != "" </span><span class="cov8" title="1">{
                b.WriteString("\nLast verification output (truncated):\n\n```text\n")
                b.WriteString(truncateStateSummary(state.LastVerificationOutput))
                b.WriteString("\n```\n")
        }</span>

        // Model escalation status
        <span class="cov8" title="1">if state.CurrentModel != "" || state.EscalationCount &gt; 0 </span><span class="cov8" title="1">{
                b.WriteString("\n## Model Escalation\n\n")
                b.WriteString("Current model: ")
                if state.CurrentModel == "" </span><span class="cov8" title="1">{
                        b.WriteString("default")
                }</span> else<span class="cov8" title="1"> {
                        b.WriteString(state.CurrentModel)
                }</span>
                <span class="cov8" title="1">b.WriteString("\n")
                if state.EscalationCount &gt; 0 </span><span class="cov8" title="1">{
                        b.WriteString(fmt.Sprintf("Escalations: %d\n", state.EscalationCount))
                }</span>
                <span class="cov8" title="1">if state.EscalationCooldownRemaining &gt; 0 </span><span class="cov8" title="1">{
                        b.WriteString(fmt.Sprintf("Cooldown remaining: %d iterations\n", state.EscalationCooldownRemaining))
                }</span>
                <span class="cov8" title="1">if state.LastEscalationReason != "" </span><span class="cov8" title="1">{
                        b.WriteString("Last escalation reason: ")
                        b.WriteString(state.LastEscalationReason)
                        b.WriteString("\n")
                }</span>
        }

        // Recovery mode status
        <span class="cov8" title="1">if state.RecoveryMode != "" </span><span class="cov8" title="1">{
                b.WriteString("\n## Recovery Mode\n\n")
                b.WriteString("Mode: ")
                b.WriteString(state.RecoveryMode)
                b.WriteString("\n")
        }</span>

        // Use atomic write pattern for consistency
        <span class="cov8" title="1">path := stateSummaryPath()
        dir := filepath.Dir(path)
        tempFile, err := os.CreateTemp(dir, ".state-summary-*.md.tmp")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">tempPath := tempFile.Name()

        writeSuccess := false
        defer func() </span><span class="cov8" title="1">{
                if !writeSuccess </span><span class="cov0" title="0">{
                        tempFile.Close()
                        os.Remove(tempPath)
                }</span>
        }()

        <span class="cov8" title="1">if _, err := tempFile.WriteString(b.String()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tempFile.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := os.Rename(tempPath, path); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">writeSuccess = true
        return nil</span>
}

func truncateStateSummary(value string) string <span class="cov8" title="1">{
        const maxSummaryBytes = 4 * 1024
        if len(value) &lt;= maxSummaryBytes </span><span class="cov8" title="1">{
                return value
        }</span>
        // Truncate by bytes, then back up to valid UTF-8 boundary
        <span class="cov8" title="1">truncated := value[:maxSummaryBytes]
        for len(truncated) &gt; 0 &amp;&amp; !utf8.ValidString(truncated) </span><span class="cov0" title="0">{
                truncated = truncated[:len(truncated)-1]
        }</span>
        <span class="cov8" title="1">return truncated</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "fmt"
        "os"
        "strings"
)

type strategyStep struct {
        Mode       string
        Iterations int
        Until      string
        If         string
}

func shouldRunStep(step strategyStep, lastResult iterationResult) bool <span class="cov8" title="1">{
        if step.If == "" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">switch strings.ToLower(step.If) </span>{
        case "stalled":<span class="cov8" title="1">
                return lastResult.Stalled</span>
        case "verify_fail":<span class="cov8" title="1">
                return lastResult.VerifyStatus == "fail"</span>
        case "verify_pass":<span class="cov0" title="0">
                return lastResult.VerifyStatus == "pass"</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Warning: unknown strategy 'if' condition %q, defaulting to true\n", step.If)
                return true</span>
        }
}

func shouldContinueUntil(step strategyStep, result iterationResult) bool <span class="cov8" title="1">{
        if step.Until == "" </span><span class="cov8" title="1">{
                // No "until" condition means continue up to max iterations
                return true
        }</span>
        <span class="cov8" title="1">switch strings.ToLower(step.Until) </span>{
        case "verify_pass":<span class="cov8" title="1">
                // Continue until verification passes
                return result.VerifyStatus != "pass"</span>
        case "verify_fail":<span class="cov8" title="1">
                // Continue until verification fails
                return result.VerifyStatus != "fail"</span>
        default:<span class="cov8" title="1">
                // Unknown condition: warn and continue up to max iterations
                fmt.Fprintf(os.Stderr, "Warning: unknown strategy 'until' condition %q, continuing to max iterations\n", step.Until)
                return true</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">//go:build !windows

package main

import "os"

func hostUIDGID() (int, int) <span class="cov0" title="0">{
        return os.Getuid(), os.Getgid()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
